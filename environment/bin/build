#!/usr/bin/env python

import os
import os.path
import re
import sys
import stat
import commands

# Utitlity modules in draco/environment/share/python
import Verbosity
import Utils
import Configure

# Local utitlity modules for these applications.
import Vendors
import arguments

die = sys.exit

# All access for user and group. Read & Execute for world.
install_access = stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH

# All access for user and group. Zilch for world.
build_access = stat.S_IRWXU | stat.S_IRWXG


# Ugh. This information is repeated in Repo.
targets = ['draco', 'clubimc', 'milagro', 'wedgehog']
dependencies = {'draco'    : [],
                'clubimc'  : ['draco'],
                'milagro'  : ['draco', 'clubimc'],
                'wedgehog' : ['draco', 'clubimc']
                }

platform = Vendors.flash


##---------------------------------------------------------------------------##
def add_package(parser, name, brief=""):

    """Add an argument for a component. The value of argument type
    appears in the help line. Typical values are 'install' and
    'source'

    If brief='.', replace it with the first character of the name.
    """

    if brief == ".": brief = name[0]

    names = ["--%s" % name]
    if brief: names.append("-%s" % brief)

    option = optparse.make_option(
        dest    = name, 
        action  = "store",
        help    = "Specify the install directory for %s" % name,
        default = "<install>/<name>/<kind>",
        *names)

    parser.add_option(option)



def make_parser()

    """Create a builder script parser. Include switches for packages
    given in the argument list.

    We assume that the first package in the list is the one being
    built while the rest are build dependencies.

    The kinds argument is used for specifying the default list
    of kinds arguments.
    """

    usage = "usage: %prog <package> source_dir [options]"

    parser = optparse.OptionParser(usage=usage)

    parser.add_option("-p", "--prefix",
                      dest = "prefix",
                      help = "Specify the build directory prefix")

    parser.add_option("-n", "--name",
                      dest = "build",
                      help = "Name of build directory. Defaults to `uname`")

    parser.add_option("-i", "--install",
                      dest = "install",
                      help = "Installation path.")

    parser.add_option("-j", "--procs",
                      dest    = "procs",
                      help    = "Number of processors to build with",
                      default = '1')

    parser.add_option("-s", "--serial",
                      action = "store_true",
                      dest   = "serial",
                      help   = "Build serial version")

    parser.add_option("-v", "--verbose",
                      action = "count",
                      dest   = "verbosity",
                      help   = "Increase the verbosity of the output. Repeatable")

    parser.add_option("-t", "--make-check",
                      action  = "store_true",
                      dest    = "check",
                      default = False,
                      help    = "Run make check, instead of just \
make. Default is no.")

    parser.add_option("--dry-run", 
                      action  = "store_false",
                      dest    = "go",
                      default = True,
                      help    = "Don't actually do anything.")

    parser.add_option("-k", "--kind",
                      action  = "append",
                      dest    = "build_kinds",
                      help    = "Specify the kind of \
build. Repeatable. Defaults to %default",
                      default = ['debug','opt'])

    parser.add_option("-l", "--location",

                      


    for p in ['draco','clubimc']: add_package(parser, p, ".")

    
    return parser


##---------------------------------------------------------------------------##
keywords = ['install', 'name', 'kind']

def extract_jayenne_dependencies(target, options):

    """Return a map of the form: {component : path}

    Keys and values are both strings. The component keys are the
    jayenne components that 'target depends on. The path values may
    contain keywords for later textual subsistution: <install>, <name>
    and <kind>.

    """

    assert(target in targets)

    depends = dependencies[target]

    depend_mapping = {}
    for component in depends:

        directory = getattr(options, component)
        depend_mapping[component] = directory

    return depend_mapping
    

def convert_jayenne_dependencies(jayenne_deps, **keywords):

    """Convert the map of jayenne dependencies into --with-blah=dir
    configure statements. Keywords in the form <fubar> in the path
    specifications are replaced with keywords from the extra names
    parameter arguments.
    """

    strings = []
    for component, path in jayenne_deps.items():

        assert(component in targets)

        # Slap a try block here to report unknown <keys>
        true_path = os.path.normpath(os.path.expanduser(
            re.sub("<(.*?)>", (lambda m: keywords[m.group(1)]), path)
            ))

        is_install_dir(true_path) or die("Path %s does not appear to \
be a jayenne component installation." % true_path)
        
        strings.append("--with-%s=%s" % (component, true_path))

    return " ".join(strings)

##---------------------------------------------------------------------------##
def make_dependency_string(component, path):
    """Return a configure string which specified a jayenne component
    dependency. """

    assert(component in targets)

    return "--with-%s=%s" % (component, path)


##---------------------------------------------------------------------------##
def is_install_dir(path):
    """Check to see if the given path looks like a install location for
    a Jayenne component"""

    return os.path.exists(os.path.join(path, "lib")) and os.path.exists(
        os.path.join(path, "include"))


##---------------------------------------------------------------------------##
def make_vendor_string(vendor_libs):
    """Make a configure string for the provided list of vendors."""

    vendor_string = " ".join(
        [Configure.make_option_string(**platform.vendors[vendor]) 
         for vendor in vendor_libs])

    return vendor_string
    
##---------------------------------------------------------------------------##
def get_mpi_string(options):

    # MPI: Use the module system to provide values.
    if options.serial:
        return ""
    else:
        mpi_inc_dir = os.environ.get("MPI_INC_DIR") or die("Variable MPI_INC_DIR not set")
        mpi_lib_dir = os.environ.get("MPI_LIB_DIR") or die("Variable MPI_LIB_DIR not set")

    return " ".join([
        "--with-c4=mpi",
        "--with-mpi=lampi",
        "--with-mpi-inc=%s" % mpi_inc_dir,
        "--with-mpi-lib=%s" % mpi_lib_dir])



##---------------------------------------------------------------------------##
compiler_names = {"pgCC" : "pgi",
                  "g++"  : "gcc"
                  }

def get_compiler_string():
    """Determine the desired compiler from the environment variable CXX, if
    possible, and return a corresponding configuration string. If the
    environment variable isn't set, return the empty string."""

    environ_cc = os.path.basename(os.environ.get("CXX", ""))

    compiler = compiler_names.get(environ_cc)
    if compiler: return "--with-cxx=%s" % compiler
    else: return ""


##---------------------------------------------------------------------------##
kind_options = {"opt"   : "--with-dbc=0 --with-opt=3 --disable-debug",
                "debug" : "--with-dbc=7 --enable-debug"
                }

known_kinds = kind_options.keys()

def get_kinds(given_kinds):
    """Expand the given kinds names into complete kinds names. Throws
    an exception if any names can't be resolved."""

    # Expand the "kinds" arguments.
    try:
        kinds = [Utils.disambiguate(k, known_kinds) for k in
                 options.build_kinds]

    except KeyError, e:
        die("Could not understand kind argument: %s" % e[0])

    return kinds



##---------------------------------------------------------------------------##
if __name__=="__main__":

    # Make a basic parser, and add options for the depedencies.
    parser = make_parser()

    (options, args) = parser.parse_args()

    # Intrepret User options
    # ======================
    
    message = Verbosity.make(options.verbosity)
    message("Options: "   + str(options), 3)
    message("Arguments: " + str(args),    3)

    # A single argument is the target. The second is the source path,
    # if it exists. 
    if len(args) == 2:
        target, source_dir = args[0:2]
    else:
        target, source_dir = args[0], os.getcwd()

    try: 
        jayenne_target = Utils.disambiguate(target, targets)
    except KeyError, e:
        die("Could not understand target name: " + target)
    message("Building jayenne target: " + jayenne_target,3)

    source_path = os.path.abspath(os.path.expanduser(source_dir))
    message("Source path: %s" % source_path, 2)

    os.path.exists(source_path) or die(
        "Directory %s does not exist." % source_path)

    configure_script = os.path.join(source_path, "configure")
    os.path.exists(configure_script) or die(
        "Can not find configure script in %s." % source_path)

    name = options.build or commands.getoutput("uname")
    message("Build name: %s" % name, 2)

    build_prefix   = os.path.abspath(options.prefix or os.getcwd())
    install_prefix = options.install or build_prefix

    message("Building with prefix:   %s" % build_prefix,   2)
    message("Installing with prefix: %s" % install_prefix, 2)


    # Build configure options
    # =======================

    mpi_string = get_mpi_string(options)
    message("MPI configuration string: " + mpi_string, 3)

    vendor_string = make_vendor_string(["sprng"])
    message("Vendor configuration string: " + vendor_string, 3)

    compiler_string = get_compiler_string()
    message("Compiler configuration string: " + compiler_string, 3)

    binding_string = "--enable-shared"
    message("Libary type string "+ binding_string, 3)

    jayenne_deps = extract_jayenne_dependencies(jayenne_target, options)
    message("Dependency configuration string: " + str(jayenne_deps), 3)


    # Get kind information
    # --------------------

    message("Provided kinds: " + " ".join(options.build_kinds), 3)
    kinds = get_kinds(options.build_kinds)
    message("Selected build kinds: " + " ".join(kinds), 2)
        

    # Configure and build each kind.
    # =============================
    for kind in kinds:


        # Create the build and installation directories:
        # ----------------------------------------------

        build_directory   = os.path.join(build_prefix,   name, kind, jayenne_target) 
        install_directory = os.path.join(install_prefix, name, kind)

        message("Making directory: %s" % build_directory, 1)
        try:
            options.go and os.makedirs(build_directory)
        except OSError, e:
            die("Failure while making directory: %s, %s" %
                (build_directory, e))

        if (build_prefix != install_prefix):
            message("Making directory: %s" % install_directory, 1)
            try:
                options.go and os.makedirs(install_directory)
            except OSError, e:
                die("Failure while making directory: %s, %s" %
                    (install_directory, e))


        # Convert the jayenne dependencies into a configuration
        # string.
        dependency_string = convert_jayenne_dependencies(
            jayenne_deps, kind=kind, name=name, install=install_prefix)


        # Set directory access: XXX Might have a problem with higher
        # directory levels here. 
        if options.go: os.chmod(build_directory,   build_access)
        if options.go: os.chmod(install_directory, install_access)
        if options.go: os.chdir(build_directory)


        # Build the configure command
        # ---------------------------

        configure = " ".join([configure_script,
                              "--prefix=%s" % install_directory,
                              compiler_string,
                              binding_string,
                              kind_options[kind],
                              vendor_string,
                              dependency_string
                              ])

        message("Configure line: \n%s" % configure, 3)


        # Run configure. XXX More sophisticated job control is probably
        # called for here.
        message("Running configure in directory: " + build_directory, 1)
        if options.go:
            (status,output) = commands.getstatusoutput(configure)
        else:
            (status,output) = (0,"")

        if status: die("Configure failed with status=%s" % status) 

        message("Completed configuration in directory " +
                build_directory, 2)



        # Build the make command:
        # -----------------------

        if options.check: target_string = "check"
        else: target_string = ""

        make = " ".join(["gmake",
                         "nj=%s" % options.procs,
                         target_string
                         ])

        message("Make line: %s" % make, 3)

        # Run make check.
        message("Running make %s in %s" % (target_string, build_directory),1)
        if options.go:
            (status,output) = commands.getstatusoutput(make)
        else:
            (status,output) = (0,"")

        if status: die("Make failed with status=%s" % status)

        message("Completed make in directory " + build_directory, 2)
        
