#!/usr/bin/env python
# -*- mode: Python -*-

import os
import os.path
import re
import sys
import stat
import commands
import optparse

# Utitlity modules in draco/environment/share/python
import Verbosity
import Utils
import Configure

# Local utitlity modules for these applications.
import Jayenne
import Platforms

die = sys.exit

# All access for user and group. Read & Execute for world.
install_access = stat.S_IRWXU | stat.S_IRWXG | stat.S_IROTH | stat.S_IXOTH

# All access for user and group. Zilch for world.
build_access = stat.S_IRWXU | stat.S_IRWXG

platform = Platforms.flash


##---------------------------------------------------------------------------##
def add_package(parser, name, brief=""):

    """Add an argument for a component. The value of argument type
    appears in the help line. Typical values are 'install' and
    'source'

    If brief='.', replace it with the first character of the name.
    """

    if brief == ".": brief = name[0]

    names = ["--%s" % name]
    if brief: names.append("-%s" % brief)

    option = optparse.make_option(
        dest    = name, 
        action  = "store",
        help    = "Specify the install directory for %s" % name,
        default = "<install>/<name>/<kind>",
        *names)

    parser.add_option(option)



def make_parser():

    """Create a builder script parser. Include switches for packages
    given in the argument list.

    We assume that the first package in the list is the one being
    built while the rest are build dependencies.

    """

    usage = "usage: %prog <package> source_dir [options]"

    parser = optparse.OptionParser(usage=usage)

    parser.add_option("-p", "--prefix",
                      dest = "prefix",
                      help = "Specify the build directory prefix")

    parser.add_option("-n", "--name",
                      dest = "build",
                      help = "Name of build directory. Defaults to `uname`")

    parser.add_option("-i", "--install",
                      dest = "install",
                      help = "Installation path.")

    parser.add_option("-j", "--procs",
                      dest    = "procs",
                      help    = "Number of processors to build with",
                      default = '1')

    parser.add_option("-s", "--serial",
                      action = "store_true",
                      dest   = "serial",
                      help   = "Build serial version")

    parser.add_option("-v", "--verbose",
                      action = "count",
                      dest   = "verbosity",
                      help   = "Increase the verbosity of the output. Repeatable")

    parser.add_option("-t", "--make-check",
                      action  = "store_true",
                      dest    = "check",
                      default = False,
                      help    = "Run make check, instead of just \
make. Default is no.")

    parser.add_option("--dry-run", 
                      action  = "store_false",
                      dest    = "go",
                      default = True,
                      help    = "Don't actually do anything.")

    parser.add_option("-k", "--kind",
                      action  = "append",
                      dest    = "build_kinds",
                      help    = "Specify the kind of \
build. Repeatable. Defaults to %default",
                      default = ['debug','opt'])


    for p in ['draco','clubimc']: add_package(parser, p, ".")

    return parser


##---------------------------------------------------------------------------##
if __name__=="__main__":

    # Make a basic parser, and add options for the depedencies.
    parser = make_parser()

    (options, args) = parser.parse_args()

    # Intrepret User options
    # ======================
    
    message = Verbosity.make(options.verbosity)
    message("Options: "   + str(options), 3)
    message("Arguments: " + str(args),    3)

    # A single argument is the target. The second is the source path,
    # if it exists. 
    if len(args) == 2:
        target, source_dir = args[0:2]
    else:
        target, source_dir = args[0], os.getcwd()

    try: 
        jayenne_target = Utils.disambiguate(target, Jayenne.targets)
    except KeyError, e:
        die("Could not understand target name: " + target)
    message("Building jayenne target: " + jayenne_target,3)

    source_path = os.path.abspath(os.path.expanduser(source_dir))
    message("Source path: %s" % source_path, 2)

    os.path.exists(source_path) or die(
        "Directory %s does not exist." % source_path)

    configure_script = os.path.join(source_path, "configure")
    os.path.exists(configure_script) or die(
        "Can not find configure script in %s." % source_path)

    name = options.build or commands.getoutput("uname")
    message("Build name: %s" % name, 2)

    build_prefix   = os.path.abspath(options.prefix or os.getcwd())
    install_prefix = options.install or build_prefix

    message("Building with prefix:   %s" % build_prefix,   2)
    message("Installing with prefix: %s" % install_prefix, 2)

    # Extract the Jayenne dependencies into a dictionary:
    jayenne_deps = Jayenne.extract_jayenne_dependencies(jayenne_target, options)
    message("Dependency configuration string: " + str(jayenne_deps), 3)


    # Build configure options
    # =======================

    mpi_string = Configure.get_mpi_string(options)
    message("MPI configuration string: " + mpi_string, 3)

    vendor_string = Configure.make_vendor_string(["sprng"])
    message("Vendor configuration string: " + vendor_string, 3)

    compiler_string = Configure.get_compiler_string()
    message("Compiler configuration string: " + compiler_string, 3)

    binding_string = "--enable-shared"
    message("Libary type string "+ binding_string, 3)



    # Get kind information
    # --------------------

    message("Provided kinds: " + " ".join(options.build_kinds), 3)
    kinds = Configure.get_kinds(options.build_kinds)
    message("Selected build kinds: " + " ".join(kinds), 2)
        

    # Configure and build each kind.
    # =============================
    for kind in kinds:


        # Create the build and installation directories:
        # ----------------------------------------------

        build_directory   = os.path.join(build_prefix,   name, kind, jayenne_target) 
        install_directory = os.path.join(install_prefix, name, kind)

        message("Making directory: %s" % build_directory, 1)
        try:
            options.go and os.makedirs(build_directory)
        except OSError, e:
            die("Failure while making directory: %s, %s" %
                (build_directory, e))

        if (build_prefix != install_prefix):
            message("Making directory: %s" % install_directory, 1)
            try:
                options.go and os.makedirs(install_directory)
            except OSError, e:
                die("Failure while making directory: %s, %s" %
                    (install_directory, e))


        # Convert the jayenne dependencies into a configuration
        # string.
        dependency_string = Jayenne.convert_jayenne_dependencies(
            jayenne_deps, dict(kind=kind, name=name, install=install_prefix))


        # Set directory access: XXX Might have a problem with
        # permissions of parent directories here.
        if options.go: os.chmod(build_directory,   build_access)
        if options.go: os.chmod(install_directory, install_access)
        if options.go: os.chdir(build_directory)


        # Build the configure command
        # ---------------------------

        configure = " ".join([configure_script,
                              "--prefix=%s" % install_directory,
                              compiler_string,
                              binding_string,
                              kind_options[kind],
                              vendor_string,
                              dependency_string
                              ])

        message("Configure line: \n%s" % configure, 3)


        # Run configure. XXX More sophisticated job control is probably
        # called for here.
        message("Running configure in directory: " + build_directory, 1)
        if options.go:
            (status,output) = commands.getstatusoutput(configure)
        else:
            (status,output) = (0,"")

        if status: die("Configure failed with status=%s" % status) 

        message("Completed configuration in directory " +
                build_directory, 2)



        # Build the make command:
        # -----------------------

        if options.check: target_string = "check"
        else: target_string = ""

        make = " ".join(["gmake",
                         "nj=%s" % options.procs,
                         target_string
                         ])

        message("Make line: %s" % make, 3)

        # Run make check.
        message("Running make %s in %s" % (target_string, build_directory),1)
        if options.go:
            (status,output) = commands.getstatusoutput(make)
        else:
            (status,output) = (0,"")

        if status: die("Make failed with status=%s" % status)

        message("Completed make in directory " + build_directory, 2)

        
