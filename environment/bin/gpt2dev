#! /usr/local/bin/perl

# This script generates gnuplot output in a variety of formats
# (the relationship to gnuplot is intended to approximate that
# of transfig to xfig).
# Brendt Wohlberg
# Most recent modification: 28 November 2001

use Getopt::Long;
use File::Basename;

$usagetxt = "usage: gpt2dev -L term [ -o options ] [-h] [-t]" .
            " [ gpt-file [ out-file ]]\n";
$helptxt= <<EOT;
gpt2dev generates gnuplot output in a variety of formats; the 
relationship to gnuplot is intended to approximate that of 
fig2dev to xfig. If an input (output) file is not specified,
input is read from stdin (written to stdout).

Options:
 -L term          Use term as output terminal
 -o options       Set options for output terminal
 -h               Display help information
 -t               List available output terminals
EOT
$helptxt = $usagetxt . "\n" . $helptxt;

# Parse command line options
GetOptions("L=s" => \$language,
	   "o=s" => \$termoptions,
	   "t+" => \$listterms,
	   "h+" => \$help) or
  die $usagetxt;

# Handle help flag
die $helptxt if ($help ne "");

# List available terminals on -t flag
if ($listterms ne "") {
  $cmdline = "echo \"set terminal\" | gnuplot 2>&1 | " .
    "sed \"s/Press return for more: //\"";
  system($cmdline);
  exit(0);
}

# Exit with error message if no term specified
die "gpt2dev: Must specify term type\n" . $usagetxt if ($language eq "");

# Set input and output file names
$gptfile = $ARGV[0];
$outfile = $ARGV[1];

# Set flag indicating pslatex term with aux option
$pslatexaux = ($language eq "pslatex" && $termoptions =~ "aux")?1:0;

# Exit with error if pslatex term with aux option requested without specifying
# an output file
die "gpt2dev: Output file must be specified for pslatex term with" .
    " aux option\n" . $usagetxt
 if ($pslatexaux && $outfile eq "");

#If input filename specified (gnuplot file is not from stdin), change
#directory to the path (if present) of the input (to allow correct handling
#of any relative filenames for data loaded by the gnuplot file) and attach
#STDIN to that file
if ($gptfile ne "") {
  $gptbasename = basename($gptfile, ".gpt");
  $gptdirname = dirname($gptfile);
  if ($gptdirname ne "") {
    $pwd = $ENV{PWD};
    system("cd " . $gptdirname);
  }
  #print $gptbasename . "\n" . $gptdirname . "\n";
  open(STDIN, "<" . $gptfile) or
    die "gpt2dev: Could not open input file " . $gptfile . "\n" . $usagetxt;
}

# Construct temporary output file name
$tmpoutfile = "/tmp/g2d" . $$;

#Open pipe to gnuplot
open(GPTPIPE, "| unset TERM DISPLAY; gnuplot") or
  die("gpt2dev: Error opening pipe to gnuplot\n");

#Work through each line in the input file
while ($line = <STDIN>) {
  if ($line =~ /\#\s*gpt2dev\s*(.+)\s*$/) {
    #If instruction line found in the input file, parse it
    #for relevant options and store them
    $instruction = $1;
    if ($instruction =~ /termoptions\s+(\w+)\s+(.*)\s*$/) {
      $term = $1;
      $options = $2;
      if ($term eq $language) {
	die "gpt2dev: The aux option for the pslatex term may not be set " .
	    "in the gnuplot file\n"
	      if ($language eq "pslatex" && $options =~ "aux");
	push(@filespecifiedoptions, $options);
      }
    } elsif ($instruction =~ /termcmd\s+(\w+)\s+(.*)\s*$/) {
      $term = $1;
      $cmd = $2;
      push(@termspecificcmds, $cmd) if ($term eq $language);
    }
  } else {
    #If no instruction found, pass this line to gnuplot
    print GPTPIPE $line;
  }
}

close(STDIN);

#Send final output generating instructions to gnuplot
print GPTPIPE "\n";
foreach $cmd ( @termspecificcmds ) {
  print GPTPIPE $cmd . "\n";
}
foreach $opt ( @filespecifiedoptions ) {
  print GPTPIPE "set term " . $language . " " . $opt . "\n";
}
print GPTPIPE "set term " . $language . " " . $termoptions .
              "\nset output \"" . $tmpoutfile . "\"\nreplot\n";

close(GPTPIPE) or die("gpt2dev: Error closing pipe to gnuplot\n");

#If necessary, change back to the directory from which gpt2dev was
#called
if ($gptdirname ne "") {
  system("cd " . $pwd);
}

#If using the pslatex term with the aux option, move the ps file
#to the current directory
if ($pslatexaux) {
  $tmpoutpsname = $tmpoutfile . ".ps";
  ($outname,$outpath,$outsuffix) = fileparse($outfile, ".pstex_t");
  $outpstexname = $outpath . $outname . ".pstex";
  system("mv " . $tmpoutpsname . " " . $outpstexname);
  $tmpoutpsbasename = basename($tmpoutpsname, ".ps");
  $outpstexbasename = basename($outpstexname, ".pstex");
}

#If output filename specified (result is not sent to stdout), attach
#STDOUT to that file
if ($outfile ne "") {
  open(STDOUT, ">" . $outfile);
}

#Open the temorary output file and send the contents to the
#final output
open(TMPFILE, "<" . $tmpoutfile) or
  die "gpt2dev: Could not open temporary file " . $tmpoutfile . "\n";
while ($line = <TMPFILE>) {
  #Convert the ps file name when using the pslatex term with the aux option
  if ($pslatexaux) {
    if ($line =~ /\includegraphics\{/) {
      $line =~ s/\includegraphics\{.*\}/\includegraphics\{$outpstexbasename\}/;
    } elsif ($line =~ /\Q$tmpoutpsbasename/) {
      $line =~ s/\Q$tmpoutpsbasename/$outpstexbasename/;
    }
  }

  #Fix up unpatched gnuplot output
  if ($line =~ /\\special\{psfile\=(.*)\.ps/) {
    $filename = $1;
    $line = <TMPFILE>
  }
  if (defined($filename) && $line =~ /\\end\{picture\}/) {
    print STDOUT "\\includegraphics{" . $filename . "}%\n";
  }
  if ($line =~ /\\special\{ps\:\sgsave/) {
    $line = <TMPFILE>;
    if ($line =~ /(\d+)\srotate\sneg/) {
      $angle = $1;
      $content = <TMPFILE>;
      $line = <TMPFILE>;
      $line = <TMPFILE>;
      print STDOUT "\\rotatebox{" . (360 - $angle) . "}{%\n";
      print STDOUT $content;
      $line = "}}%\n";
    }
  }
  #End of fix


  print STDOUT $line;
}

close(TMPFILE);
close(STDOUT);
unlink <$tmpoutfile*>
