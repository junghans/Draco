#! /usr/bin/env python

from optparse import OptionParser
from optparse import OptionValueError
import tempfile, tarfile
import os

import Verbosity, Repo, CVS, Cleanup

# Global application data:
packages = ['draco', 'clubimc', 'wedgehog']

usage = """usage:

  %prog component [[date:]version] [-d dependency [date:]version]

Quick intro:

  To check out a package and it's dependencies

  > pitch <package>

  Or:

  > pitch <package> <version>

  Where <version> can be a cvs tag or of the form
  "date:<some_date>". See the cvs manual for allowable <some_date>
  values.

  Corresponding versions of the dependencies of <package> are
  retrieved automatically and placed at the same level of the
  directory tree. Specific versions of the dependencies can be
  seleceted with '-d', as in:

  > pitch <package> -d <depednecy> <version>

  Checking out the head of main package implies that the head of
  dependencies will be used as well. A specific version of the main
  package will get in corresponding release versions of the
  dependencies, unless these are over-ridden with the '-d' option.

  Use -t or --tarball to make a tarball.

  Use -l or --location to specify a filesystem location. This is
  either where the code will be checked out or where the final tarball
  will reside.

  Use -n or --name to specify a release name. This will cause all the
  packages to appear under <name> in both the source tree or the
  tarball. If <location> is speficied, <name> is appended to
  <location> in source checkouts.

  Examples:

  Suppose some_package depends on another_package

  > pitch some_package -n big_release 

  will create big_release in the CWD. Directories some_package and
  another_package will appear here.

  > pitch some_package -n big_release -t tarball_file -l some_dir

  creates a tarfile some_dir/tarball_file.tgz. The packages inside of
  the tarball are all under the top-level directory: big_release.

  > pitch some_package -t tarball_file

  creates a tarball names tarball_file in the CWD. The packages in the
  tarball will not have a common top level directory.

"""

parser = OptionParser(usage=usage)
parser.add_option("-d", "--depend",
                  type     = "string",
                  nargs    = 2,
                  default  = [],
                  action   = "append",
                  metavar  = "COMPONENT TAG",
                  help     = "Set a version/tag for a dependency"
                  )

parser.add_option("-v", "--verbose",
                  action   = "count",
                  dest     = "verbosity",
                  help     = "Increase verbosity of output. Multiple uses supported.",
                  )

parser.add_option("-e", "--export",
                  action   = "store_true",
                  dest     = "export",
                  help     = "Export sources, instead of checking them out",
                  )

parser.add_option("-l", "--location",
                  action   = "store",
                  dest     = "location",
                  help     = "Location for resulting source tree or tarball."
                  )

parser.add_option("-t", "--tarball",
                  action   = "store",
                  dest     = "tarfile",
                  help     = "Create a tarball of the source tree"
                  )

parser.add_option("-n", "--name",
                  type     = "string",
                  action   = "store",
                  default  = "",
                  dest     = "name",
                  help     = "Specify a top-level name for source tree."
                  )

##---------------------------------------------------------------------------##
class ArgumentError(Exception):
    "An exception class for inconsistent combinations of arguments."
    pass


##---------------------------------------------------------------------------##
def extract_module(args):

    """Return a CVS module corresponding the expansion of the given
    name and version.  """
    
    # Get a tag:
    if len(args) == 2:
        tag_name = args[1]
    else:
        tag_name = ''
    

    # Get module name
    try:
        name = Repo.disambiguate_component(args[0])
    except KeyError:
        sys.exit("Could not determine correct package from: %s" % \
                 args[0])

    module = CVS.Module(name, tag=tag_name)

    return module


##---------------------------------------------------------------------------##
def form_get_draco(package, checkout_head = False, import_only = False):

    depends = Repo.get_depends(package)
    depends_repos = [Repo.get_cvs_repo(dep) for dep in depends]

    command = "./get_draco"

    if checkout_head:
        command += " -H"
    else:
        command += " -l"

    if import_only:
        command += " -i"

    if 'draco' in depends_repos:
        command += " -d %s" % Repo.get_cvs_repo_dir('draco')

    if 'jayenne' in depends_repos:
        command += " -j %s" % Repo.get_cvs_repo_dir('jayenne')

    return command


##---------------------------------------------------------------------------##
if __name__=="__main__":

    (options, args) = parser.parse_args()

    # Parse error checks:
    if len(args) < 1: parser.error("No top component specified.")
    if len(args) > 2: parser.error("Too many parameters")

    message = Verbosity.make(options.verbosity)

    message("Options: %s" % str(options), 3)
    message("Arguments: %s " % str(args), 3)

    # Location/Tarball combinations:
    # Neither:   Put source in CWD. No tarball
    # -l only:   Put source at location
    # -t only:   Put tarball in CWD.       Requires temp dir.
    # -l and -t: Put tarball at location.  Requires temp dir.

    # if <name> is specified, we check out each package under
    # <location>/<name>. For tarfiles, we then move each source
    # directory to <name>/<package>.

    
    # Set default location to CWD:
    if not options.location: options.location = os.getcwd()
    options.location = os.path.abspath(options.location)
    
    # If <location> doesn't exist, try to create it.
    # Might want to make this mkdirs for deeper dir names. 
    if not os.path.exists(options.location):
        try:
            os.mkdir(options.location)
        except:
            sys.exit("Failed to create directory %s:" % options.location)


    # Set the value of checkout_dir
    if options.tarfile:
        checkout_dir = tempfile.mkdtemp()
        Cleanup.delete_on_exit(checkout_dir)
        message("Created a temporary directory: %s" % checkout_dir, 3)
    elif options.location:
        checkout_dir = options.location
        
    checkout_dir = os.path.join(checkout_dir, options.name)
    if not os.path.exists(checkout_dir): os.mkdir(checkout_dir)  # XXX trap failure
    message("Directory for checked out sources: %s" % checkout_dir)


    # Get the CVS.Module object and Repository object, checkout module, and
    # cd there: 
    main_module = extract_module(args)
    repository = CVS.Repository(Repo.get_cvs_dir(main_module.name))

    # Get the full and named depenency information
    named_dependency_modules = \
        [extract_module(dep) for dep in options.depend] 
    all_dependency_names = Repo.get_depends(main_module.name)
    message("Named dependencies: %s" % map(str, named_dependency_modules), 3)
    message("All dependencites: %s"  % all_dependency_names,   3)




    message("Checking out package: %s" % main_module, 1)
    message("With tag: %s" % main_module.tag, 1)
    location = CVS.checkout(repository, main_module, checkout_dir, options.export, message)
    os.chdir(location)
    message("Changing to new directory: %s" % location, 2)


    # Run get_draco with correct repositories for dependencies. 
    # We need to know if the main module is a head version.
    main_head = (main_module.tag.kind == "h")
    command = form_get_draco(main_module.name, main_head)
    message("Running get_draco command in: %s" % location, 1)
    message("Command: %s" % command, 2)
    os.system(command)


    # Run autoconf in the main package directory
    autoconf_script = "./%s_config" % main_module.name
    message("Running autoconf script in: %s" % location, 1)
    message("Command: %s" % autoconf_script, 2)
    os.system(autoconf_script)





    # Enter dependency directories
    for dependency in all_dependency_names:

        #1. Find the dependency's path and go there.
        dependency_path = os.path.join(checkout_dir, dependency)
        message("Changing directory to: %s" % dependency_path, 2)
        os.chdir(dependency_path)

        #2. run cvs update if this was a named depdenency.
        matching_named_dep = filter(lambda x: x.name == dependency,
                                    named_dependency_modules)

        if matching_named_dep:
            # Use the last tag, if multiple ones were provided:
            named_dep_tag = matching_named_dep[-1].tag
            command = "cvs update %s" % named_dep_tag
            message("Running cvs update in dependent module: %s" % \
                    dependency, 1)
            message("With command: %s" % command, 2)
            os.system(command)
            

        #3. run get_draco -i, if it isn't draco.
        if dependency != 'draco':
            command = form_get_draco(dependency, import_only=True)
            message("Executing get_draco in %s" % dependency_path, 1)
            message("Command: %s" % command)
            os.system(command)

        #4. run the autoconf script.
        autoconf_script = "./%s_config" % dependency
        message("Running autoconf script in: %s" % dependency_path, 1)
        message("Command: %s" % autoconf_script, 2)
        os.system(autoconf_script)


    # Make the tarfile
    if options.tarfile:
        filename = os.path.join(
            options.location, 
            options.tarfile + ".tgz")
        tarfile = tarfile.open(filename, 'w:gz')

        if options.name:
            tarfile.add(checkout_dir, options.name)
        else:
            tarfile.add(os.path.join(checkout_dir, main_module.name))
            for dir in [main_module.name]+all_dependency_names:
                tarfile.add(os.path.join(checkout_dir, dir), options.tarfile)

        tarfile.close()

        
