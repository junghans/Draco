#! /usr/bin/env python
# -*- mode: Python -*-

from optparse import OptionParser
from optparse import OptionValueError
import tempfile, tarfile
import os, sys

import Verbosity, CVS, Cleanup, Checkout, Jayenne, Utils

usage = """

  %prog [module] [-r [date:]version] [-d dependency [date:]version]

Quick intro:

  To check out a package and it's dependencies

  > pitch <package>

  Or:

  > pitch <package> <version>

  Where <version> can be a cvs tag or of the form
  "date:<some_date>". See the cvs manual for allowable <some_date>
  values.

  Corresponding versions of the dependencies of <package> are
  retrieved automatically and placed at the same level of the
  directory tree. Specific versions of the dependencies can be
  seleceted with '-d', as in:

  > pitch <package> -d <depednecy> <version>

  Checking out the head of main package implies that the head of
  dependencies will be used as well. A specific version of the main
  package will get in corresponding release versions of the
  dependencies, unless these are over-ridden with the '-d' option.

  Use -t or --tarball to make a tarball.

  Use -l or --location to specify a filesystem location. This is
  either where the code will be checked out or where the final tarball
  will reside.

  Use -n or --name to specify a release name. This will cause all the
  packages to appear under <name> in both the source tree or the
  tarball. If <location> is specified, <name> is appended to
  <location> in source checkouts.

  Examples:

  Suppose some_package depends on another_package

  > pitch some_package -n big_release 

  will create big_release in the CWD. Directories some_package and
  another_package will appear here.

  > pitch some_package -n big_release -t tarball_file -l some_dir

  creates a tarfile some_dir/tarball_file.tgz. The packages inside of
  the tarball are all under the top-level directory: big_release.

  > pitch some_package -t tarball_file

  creates a tarball names tarball_file in the CWD. The packages in the
  tarball will not have a common top level directory.

"""

parser = OptionParser(usage=usage)
parser.add_option("-r", "--tagname",
                  type    = "string",
                  action  = "store",
                  dest    = "tagname",
                  default = "",
                  help    = "Specify a symbolic tag for the package."
                  )

parser.add_option("-d", "--depend",
                  type     = "string",
                  nargs    = 2,
                  default  = [],
                  action   = "append",
                  metavar  = "COMPONENT TAG",
                  help     = "Set a version/tag for a dependency"
                  )

parser.add_option("-l", "--location",
                  action   = "store",
                  dest     = "location",
                  help     = "Location for resulting source tree or tarball."
                  )

parser.add_option("-t", "--tarball",
                  action   = "store",
                  dest     = "tarfile",
                  help     = "Create a tarball of the source tree"
                  )

parser.add_option("-n", "--name",
                  type     = "string",
                  action   = "store",
                  default  = "",
                  dest     = "name",
                  help     = "Specify a top-level name for source tree."
                  )

parser.add_option("-e", "--export",
                  action   = "store_true",
                  dest     = "export",
                  help     = "Export sources, instead of checking them out",
                  )

parser.add_option("-v", "--verbose",
                  action   = "count",
                  dest     = "verbosity",
                  help     = "Increase verbosity of output. Multiple uses supported.",
                  )

##---------------------------------------------------------------------------##
##---------------------------------------------------------------------------##
##---------------------------------------------------------------------------##
def cvs_update(tag):
    kind, name = Checkout.parse_tag(tag)
    tag_string = CVS.make_tag(kind, name)

    os.system("cvs update %s" % tag_string)

##---------------------------------------------------------------------------##
##---------------------------------------------------------------------------##
def parse_input(options, args):

    module, tag = Checkout.parse_input(options, args)

    # Set default location to CWD:
    if not options.location: options.location = os.getcwd()
    options.location = os.path.abspath(options.location)
    

    # Set the value of checkout_dir
    if options.tarfile:
        checkout_dir = tempfile.mkdtemp()
        Cleanup.delete_on_exit(checkout_dir)
        message("Created a temporary directory: %s" % checkout_dir, 3)
    elif options.location:
        checkout_dir = options.location
        
    checkout_dir = os.path.join(checkout_dir, options.name)
    message("Directory for checked out sources: %s" % checkout_dir)

    # Return a dictonary of named modules and their tags.
    named_dependencies = dict(options.depend)

    return module, tag, checkout_dir, named_dependencies



##---------------------------------------------------------------------------##
##---------------------------------------------------------------------------##
if __name__=="__main__":

    (options, args) = parser.parse_args()
    message = Verbosity.make(options.verbosity)
    message("Options: %s" % str(options), 3)
    message("Arguments: %s " % str(args), 3)

    try:

        (main_module_name, tag, checkout_dir, named_depends) = \
            parse_input(options, args)

        (tag_kind, tag_name) = Checkout.parse_tag(tag)

    except Utils.ArgumentsException, e:
        parser.error(str(e))
        
    message("main module name:   %s" % main_module_name, 3)
    message("tag string:         %s" % tag, 3)
    message("checkout directory: %s" % checkout_dir, 3)
    message("work location:      %s" % options.location, 3)
    message("Named dependencies: %s" % named_depends, 3)
    
    # Location/Tarball combinations:
    # Neither:   Put source in CWD. No tarball
    # -l only:   Put source at location
    # -t only:   Put tarball in CWD.       Requires temp dir.
    # -l and -t: Put tarball at location.  Requires temp dir.

    # if <name> is specified, we check out each package under
    # <location>/<name>. For tarfiles, we then move each source
    # directory to <name>/<package>.


    if not Jayenne.is_valid_package(main_module_name):
        parser.error("Unrecognized package name: %s" % main_module_name)

    # If the necessary directories don't exist, create them.
    if not os.path.exists(options.location):
        os.makedirs(options.location) 

    if not os.path.exists(checkout_dir): 
        os.makedirs(checkout_dir)
        


    # Main Module:
    # ------------

    main_module = Checkout.checkout(
        main_module_name, None, checkout_dir, options.export,
        tag_kind, tag_name, message)

    os.chdir(main_module.path);
    message("Changed dir to %s" % os.getcwd(), 3)

    # Run correct get_draco command
    all_deps = Jayenne.get_dependencies(main_module.package.name)
    is_head  = bool(tag_kind == "head")
    message("All dependencies: %s" % all_deps, 2)
    message("Is head version?: %s" % is_head,  2)
    os.system(Jayenne.get_draco(all_deps, is_head, import_only=False))

    # Run autoconf script.
    os.system(Jayenne.autoconf(main_module.package.name))




    # Dependencies:
    # -------------

    for module in all_deps:
        message("Working on module %s" % module, 1)

        # Find it's path and enter.
        dep_path = os.path.join(checkout_dir, module)
        os.chdir(dep_path)
        message("Changing directory to %s" % dep_path)
        
        if module in named_depends:
            cvs_update(named_depends[module])
            
        if module != 'draco':  
            deps = Jayenne.get_dependencies(module)
            os.system(Jayenne.get_draco(deps, is_head, import_only=True))

        # Run autoconf script.
        os.system(Jayenne.autoconf(module))


    # Optional tarfile
    # ----------------

    if options.tarfile:
        filename = os.path.join(
            options.location, 
            options.tarfile + ".tgz")
        tarfile = tarfile.open(filename, 'w:gz')

        if options.name:
            tarfile.add(checkout_dir, options.name)
        else:
            tarfile.add( main_module.output_dir() )
            for name in all_deps:
                dir = os.path.join(checkout_dir, name)
                tarfile.add(dir, name)

        tarfile.close()

        
