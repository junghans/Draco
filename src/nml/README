		Physical Dynamics Namelist Utility
			Geoffrey Furnish
			15 January  1994

This is the README file for NML.  Actually most info is in the
document which is in the doc directory.  This is mainly just a scratch
pad for me to make notes to myself about what is going on and where
this is going.

On 14/15 January 1994, version 1.0 of the utility was finalized.  This
version is not really "complete" in the sense that I would have
wanted, but it is more like "the end of a line."  Future work on this
project is going to take a significantly different tack, so I made the
1.0 cut in order to make a clear break.

GOALS for 2.0:

NML was my /very first/ C++ program, started in January '92 roughly.
In the succeeding 2 years, I have learned a /lot/ about C++, and now
have a much better grasp on how to write C++ code.  The 2.0 NML will
largely seek to be a rewrite of the code to use more normal C++ coding
practices. 

It will use a String class !!!.
It will use a templated List class !!!

It probably will not use templated item types.  This is because one of
the central structures in the code is a list of pointers to items.
These are dereferenced through the base class and virtual functions
are invoked.  It isn't clear to me that this mechanism will work
correctly if templated items of different paramaterizing types are on
the same list.

It will assume a C++ language capability at the level of Cfront 3 or
GCC 2.x.  No more suupport for G++ 1.36, Cfront 2.x, etc.

Features:

This version of NML will also seek to provide significantly more
features than previously.

Top of the desired features list is support for dynamically
configurable input sets.  This will be acheived by providing a
callback facility so that anytime an item has it's value set, a (set
of) callback(s) to user code can be generated.  These callbacks can
then perform a variety of actions to modify the namelist input set (as
well as whatever other general processing one might do with
callbacks), such as adding and deleting items or even whole lists,
changing default values, and the like.

Additionally, the Tk interface will be improved upon in ways that
allow it to work with this dynamic configuration mechanism.  Use of
the tkapp object, while nifty, has proven to be a bit of a liability
due to the excessive rate at which the programmatic interface to Tk
has changed.  This version of nml will attempt to "fit in" with wish
variants a little better by using the current standard programmatic
interface.

Furthermore, probably, it will use [incr tcl] instead of just straight
tcl to implement the interface.  Hopefully this object oriented widget
construction capability will make it easier to build robust user
interface mega widgets corresponding to the natural concepts of nml
input decks.

Finally, an effort will be made to allow the nml tk interface to more
easily coexist with other tk interface items the user want to use in
the code.
