//----------------------------------*-C++-*----------------------------------//
/*! 
 * \file   amr_mesh/Release.hh
 * \author B.T. Adams
 * \date   Fri Aug 27 10:33:26 1999
 * \brief  Header file for amr_mesh library release function.
 */
//---------------------------------------------------------------------------//
// $Id$
//---------------------------------------------------------------------------//

#ifndef __imc_Release_hh__
#define __imc_Release_hh__

//===========================================================================//
// namespace version - 
//
// Purpose : Return the version of imc; 
// this can be used to get exact version information in codes that 
// use imc
// 
//===========================================================================//

#include <string>

namespace rtt_imc 
{
    const std::string release();
}

#endif                          // __imc_Release_hh__


/*!
 * \page amr_overview Overview of the Adaptive Mesh Refinement (AMR) package
 *
 * \version 1_0_0
 *
 * <h3> Introduction </h3>
 * The amr_mesh package consists of numerous functions that allow the creation
 * and manipulation of continous adaptive refinement (CAR) cartesian 
 * unstructured (CU) mesh class objects for use within transport codes. 
 * Although the class is generated in C++, a shadow object interface is
 * provided so that Fortran 90 (F90) codes may also use this data structure.
 * The AMR mesh package has been used in conjunction with both the milagro
 * implicit monte carlo C++ code and the zatharus/centuari (P1 Diffusion 
 * with variable eddington factor correction) F90 code. The CAR_CU_Mesh class 
 * contains several field member classes including:
 * <ul>
 *  <li> Cell-Centered Scalar Field (CCSF)
 *  <li> Cell-Centered Vector Field (CCVF)
 *  <li> Face-Centered Scalar Field (FCSF)
 *  <li> Face-Centered Discontinuous Scalar Field (FCDSF)
 *  <li> Face-Centered Vector Field (FCVF)
 *  <li> Node-Centered Scalar Field (NCSF)
 *  <li> Node-Centered Vector Field (NCVF).
 * </ul> 
 *
 * <h3> Intended Usage </h3>
 * The CAR_CU_Mesh class is patterned after the Draco orthogonal structured 
 * mesh (OS_Mesh) class and thus functions similarly. The intended usage is 
 * as follows:
 *
 * 1) A CAR_CU_Interface class object is instantiated by the main program. 
 *    The interface class contains member functions to parse both the user's
 *    input file and a continuous adaptive refinement mesh file in the RTT
 *    format (the latter file can be generated by the mesh generation codes
 *    ICEM and X3D). An RTT_Format object is instantiated and returned by the 
 *    parsing member function and actually reads the mesh file. The RTT_Format
 *    class is equipted with numerous member functions that allow accessing the
 *    mesh data and this object also automatically determines the connectivity
 *    of the mesh nodes, sides, and cells. In C++ the CAR_CU_Interface 
 *    parsing member functions must be invoked directly within the calling 
 *    program, while these functions are invoked automatically by the shadow 
 *    object interface of the CAR_CU_Interface class constructor when it is 
 *    called from a Fortran code. The CAR_CU_Interface data accessor functions
 *    are also shadowed so that the remainder of the input data is available.
 *
 * 2) A CAR_CU_Builder class object is instantiated by the main program. The
 *    mesh builder contains the build_Mesh member function that constructs the
 *    CAR_CU_Mesh class object (and its contained Coord_Sys and Layout class 
 *    objects). This member function takes a smart pointer to the RTT_Format
 *    class object as it single input argument and returns a smart pointer to
 *    the new CAR_CU_Mesh class object. In C++ this member function must be 
 *    invoked directly within the calling program, while this function is 
 *    invoked automatically by the shadow object interface of the 
 *    CAR_CU_Builder class constructor when it is called from a Fortran code.
 *    Only the constructor and destructor are shadowed for the CAR_CU_Builder.
 *
 * 3) A smart pointer to the CAR_CU_Interface class object is the single 
 *    argument to the Opacity_Builder constructor, which builds an Opacity
 *    class object and returns its address. While these class objects are
 *    actually in the Draco implicit monte carlo (imc) namespace, a shadow
 *    object interface for these C++ class objects is provided in the AMR
 *    mesh package so that Fortran 90 codes can construct and access the 
 *    required Opacity data structure.
 *
 * 4) A smart pointer to the CAR_CU_mesh class object is the single 
 *    argument to the build_Mat member function of the Opacity_Builder, which 
 *    builds an Mat_State class object and returns a smart pointer to the new
 *    new class object. While the Mat_State class object is actually in the 
 *    Draco implicit monte carlo (imc) namespace, a shadow object interface 
 *    for this C++ class objects is provided in the AMR mesh package so that 
 *    Fortran 90 codes can construct and access the required Mat_State data 
 *    structure.
 *
 * 5) The CAR_CU_Interface and CAR_CU_Builder class objects may be eliminated
 *    by calling their associated destructors after the CAR_CU_Mesh, Opacity,
 *    and Mat_State class objects have been constructed (assuming that any 
 *    needed data in the remainder of the CAR_CU_Interface class object has 
 *    been retained in alternate data structures).
 *
 * 6) The CAR_CU_mesh class contains all of the required member functions that
 *    are required to perform either a monte carlo or discrete ordinates 
 *    transport calulation. A shadow object interface exists for the majority
 *    of these functions (some of the member functions specific to monte carlo
 *    are not shadowed) so that they can be utilized within a Fortran 90 code.
 *    Mesh field classes can be constructed and accessed at will using either
 *    programming language.
 *
 * <h3> Other Draco Packages </h3>
 * The AMr mesh package uses the Draco ds++ services library, 
 * and the Draco C4 communication library.
 */

//---------------------------------------------------------------------------//
//                              end of Release.hh
//---------------------------------------------------------------------------//
