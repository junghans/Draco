//----------------------------------*-C++-*----------------------------------//
// persist.cc
// Geoffrey Furnish
// 16 May 1994
//---------------------------------------------------------------------------//
// @> A persistence class to help work with the Perstalyzer.
//---------------------------------------------------------------------------//

#include "util/persist.hh"

#include "spdf/spdf_stream.hh"

#include "ds++/Assert.hh"

#include <stdarg.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <iostream.h>
#include <iomanip.h>

//===========================================================================//
// class persist - Adjunct to the Perstalyzer

// The persist class provides a series of helper functions which are used by
// the Perstalyzer.  Client classes (those which will have persistence
// capability autogenerated by the Perstalyzer) should inherit from persist.
// This endows the class with acess to a number of methods which perform
// reading and writing of various types of data to and from the object state
// file.
//===========================================================================//

//---------------------------------------------------------------------------//
// Default constructor.  Allocate work space.
//---------------------------------------------------------------------------//

persist::persist()
{
    buf = new char[ buflen ];
    ss  = new char[ buflen ];
}

//---------------------------------------------------------------------------//
// Copy constructor.  Allocate private work space.
//---------------------------------------------------------------------------//

persist::persist( const persist& p )
{
    buf = new char[ buflen ];
    ss  = new char[ buflen ];
}

//---------------------------------------------------------------------------//
// Destructor, free internal work space.
//---------------------------------------------------------------------------//

persist::~persist()
{
    delete[] buf;
    delete[] ss;
}

//---------------------------------------------------------------------------//
// Assignment operator.  We don't need to duplicate anything, since this class
// effectively has no internal state.
//---------------------------------------------------------------------------//

persist& persist::operator=(const persist& p )
{
    return *this;
}

//---------------------------------------------------------------------------//
// Dump a "printf" style formatted string to the file.
//---------------------------------------------------------------------------//

int persist::p_printf( ofstream& ofs, const char *s, ... )
{
    va_list args;
    va_start(args,s);

    int rc = vsprintf( buf, s, args );
    
    ofs << buf;

    return rc;
}

// GRRRRRRRRRRRRRRRRRRRRRRRRRRR !!!!!!!!!!!!!!!
// Moronic Sun OS doesn't have vsscanf.  That's probably indicative of
// a general portability liability with this section of code, so I
// guess, grrrrrr, I'll rip it out and make people do things the hard
// way. grrrrrrrr.  I HATE Sun OS. grrrrrrrrrrrr.

// int persist::p_scanf( ifstream& ifs, const char *s, ... )
// {
//     ifs.getline( buf, buflen );

//     va_list args;
//     va_start(args,s);

//     return vsscanf( buf, s, args );
// }

//---------------------------------------------------------------------------//
// p_require()

// This is used to "absolutely require" the presence of a literal string at
// this point in the file.  This is not done using Assert so that it won't be
// removable.  In other words, this is a check I want done no matter what.
// No matter how confident the user is of the rest of the code.
//---------------------------------------------------------------------------//

void persist::p_require( ifstream& ifs, const char *s )
{
    int len = strlen(s);

    for( int i=0; i < len; i++ ) {
	char c;
	ifs.get(c);
//	cout << "Expected :" << s[i] << ": got :" << c << ":\n" << flush;
	if ( c != s[i] ) {
	    cout << "persis::p_require, expected :" << s <<":\n";
	    cout << "currently expecting to fetch :" << s[i] << ": at "
		 << i << " but got " << c << endl;

	    throw( "persist: Match failed" );
	}
    }
}

//---------------------------------------------------------------------------//
// Write an int.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, int  v )
{
    ofs << s << " = " << v << endl;
}

//---------------------------------------------------------------------------//
// Read an int.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, int& v )
{
    streampos beg = ifs.tellg();

    ifs.getline( buf, buflen );
    sscanf( buf, "%s = %d", ss, &v );

    if ( strcmp(s,ss) != 0 ) {
	ifs.seekg( beg );
	throw( prst_read_xcpt<int>( ifs, s, v ) );
    }
}

//---------------------------------------------------------------------------//
// Write a DS++ String object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, String  v )
{
    ofs << s << " = (" << v.len() << ")\n";
    ofs << &v[0] << endl;
}

//---------------------------------------------------------------------------//
// Read a DS++ String object.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, String& v )
{
    streampos beg = ifs.tellg();

    int len;
    ifs.getline( buf, buflen );
    sscanf( buf, "%s = (%d)", ss, &len );

    if ( strcmp(s,ss) != 0 ) {
	ifs.seekg( beg );
	throw( prst_read_xcpt<String>( ifs, s, v ) );
    }

    v = "";
    char c;
    for( ; len; v += c, len-- )
	ifs.get(c);

    ifs.get(c);			// suck in the \n.
    if ( c != '\n' )
	throw( "persist: improperly terminated String" );
}

//---------------------------------------------------------------------------//
// Write a DS++ DynArray<int> object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, DynArray<int>& v )
{
    int base = v.Get_base();
    int size = v.Get_size();

    ofs << "DynArray<int>: " << s << " ==>" << endl;
    ofs << "base = " << base << endl;
    ofs << "size = " << size << endl;

    spdf_ofstream sofs(ofs);

    sofs.wr( &v[base], size );

    ofs << "DynArray<int> : done.\n";
}

//---------------------------------------------------------------------------//
// Read a DS++ DynArray<int> object.
//---------------------------------------------------------------------------//

void persist::prst_read( ifstream& ifs, const char *s, DynArray<int>& v )
{
    char name[ 100 ];
    int base, size, nrd;

    p_require( ifs, "DynArray<int>: " );
    ifs.getline( buf, buflen );
    sscanf( buf, "%s ==>", name );
    if (strcmp(s,name)) {
 	throw( "persist: unable to read DynArray<int>" );
    }

    ifs.getline( buf, buflen );
    sscanf( buf, "base = %d", &base );

    ifs.getline( buf, buflen );
    sscanf( buf, "size = %d", &size );

    DynArray<int> r( size, base );

    spdf_ifstream sifs(ifs);

    sifs.rd( &r[base], nrd, size );

    if ( nrd != size ) {
	throw( "Unable to recover DynArray<int>." );
    }

    v = r;

    p_require( ifs, "DynArray<int> : done.\n" );
}

//---------------------------------------------------------------------------//
// Write a DS++ DynArray<float> object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, DynArray<float>& v )
{
    int base = v.Get_base();
    int size = v.Get_size();

    ofs << "DynArray<float>: " << s << " ==>" << endl;
    ofs << "base = " << base << endl;
    ofs << "size = " << size << endl;

    spdf_ofstream sofs(ofs);

    sofs.wr( &v[base], size );

    ofs << "DynArray<float> : done.\n";
}

//---------------------------------------------------------------------------//
// Read a DS++ DynArray<float> object.
//---------------------------------------------------------------------------//

void persist::prst_read( ifstream& ifs, const char *s, DynArray<float>& v )
{
    char name[ 100 ];
    int base, size, nrd;

    p_require( ifs, "DynArray<float>: " );
    ifs.getline( buf, buflen );
    sscanf( buf, "%s ==>", name );
    if (strcmp(s,name)) {
 	throw( "persist: unable to read DynArray<float>" );
    }

    ifs.getline( buf, buflen );
    sscanf( buf, "base = %d", &base );

    ifs.getline( buf, buflen );
    sscanf( buf, "size = %d", &size );

    DynArray<float> r( size, base );

    spdf_ifstream sifs(ifs);

    sifs.rd( &r[base], nrd, size );

    if ( nrd != size ) {
	throw( "Unable to recover DynArray<float>." );
    }

    v = r;

    p_require( ifs, "DynArray<float> : done.\n" );
}

//---------------------------------------------------------------------------//
// Write a DS++ DynArray<double> object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, DynArray<double>& v )
{
    int base = v.Get_base();
    int size = v.Get_size();

    ofs << "DynArray<double>: " << s << " ==>" << endl;
    ofs << "base = " << base << endl;
    ofs << "size = " << size << endl;

    spdf_ofstream sofs(ofs);

    sofs.wr( &v[base], size );

    ofs << "DynArray<double> : done.\n";
}

//---------------------------------------------------------------------------//
// Read a DS++ DynArray<double> object.
//---------------------------------------------------------------------------//

void persist::prst_read( ifstream& ifs, const char *s, DynArray<double>& v )
{
    char name[ 100 ];
    int base, size, nrd;

    p_require( ifs, "DynArray<double>: " );
    ifs.getline( buf, buflen );
    sscanf( buf, "%s ==>", name );
    if (strcmp(s,name)) {
 	throw( "persist: unable to read DynArray<double>" );
    }

    ifs.getline( buf, buflen );
    sscanf( buf, "base = %d", &base );

    ifs.getline( buf, buflen );
    sscanf( buf, "size = %d", &size );

    DynArray<double> r( size, base );

    spdf_ifstream sifs(ifs);

    sifs.rd( &r[base], nrd, size );

    if ( nrd != size ) {
	throw( "Unable to recover DynArray<double>." );
    }

    v = r;

    p_require( ifs, "DynArray<double> : done.\n" );
}

//---------------------------------------------------------------------------//
// Write a float.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, float  v )
{
    ofs << s << " = " << v << endl;
}

//---------------------------------------------------------------------------//
// Read a float.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, float& v )
{
    streampos beg = ifs.tellg();

    ifs.getline( buf, buflen );
    sscanf( buf, "%s = %f\n", ss, &v );

    if ( strcmp(s,ss) != 0 ) {
	ifs.seekg( beg );
	throw( prst_read_xcpt<float>( ifs, s, v ) );
    }
}

//---------------------------------------------------------------------------//
// Write a Mat1<float> object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, Mat1<float>& v )
{
    ofs << "Mat1<float>: " << s << " ==>" << endl;
    ofs << "nx = " << v.nx() << endl;

    spdf_ofstream sofs(ofs);

    sofs.wr( &v[0], v.nx() );

    ofs << "Mat1<float> : done.\n";
}

//---------------------------------------------------------------------------//
// Read a Mat1<float> object.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, Mat1<float>& v )
{
    char name[ 100 ];
    int nx, nrd;
    
    p_require( ifs, "Mat1<float>: " );
    ifs.getline( buf, buflen );
    sscanf( buf, "%s ==>", name );
    if (strcmp(s,name)) {
	throw( "persist: unable to read Mat1<float>" );
    }

    ifs.getline( buf, buflen );
    sscanf( buf, "nx = %d", &nx );

    Mat1<float> r( nx );

    spdf_ifstream sifs(ifs);

    sifs.rd( &r[0], nrd, nx );

    if ( nrd != nx ) {
	throw( "Unable to recover Mat1<float>." );
    }

    v = r;

    p_require( ifs, "Mat1<float> : done.\n" );
}

//---------------------------------------------------------------------------//
// Write a double.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, double  v )
{
    ofs << s << " = " << setprecision(DBL_DIG) << v << endl;
}

//---------------------------------------------------------------------------//
// Read a double.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, double& v )
{
    streampos beg = ifs.tellg();

    ifs.getline( buf, buflen );
    sscanf( buf, "%s = %lf\n", ss, &v );

    if ( strcmp(s,ss) != 0 ) {
	ifs.seekg( beg );
	throw( prst_read_xcpt<double>( ifs, s, v ) );
    }
}

//---------------------------------------------------------------------------//
// Write a Mat1<double> object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, Mat1<double>& v )
{
    ofs << "Mat1<double>: " << s << " ==>" << endl;
    ofs << "nx = " << v.nx() << endl;

    spdf_ofstream sofs(ofs);

    sofs.wr( &v[0], v.nx() );

    ofs << "Mat1<double> : done.\n";
}

//---------------------------------------------------------------------------//
// Read a Mat1<double> object.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, Mat1<double>& v )
{
    char name[ 100 ];
    int nx, nrd;
    
    p_require( ifs, "Mat1<double>: " );
    ifs.getline( buf, buflen );
    sscanf( buf, "%s ==>", name );
    if (strcmp(s,name)) {
	throw( "persist: unable to read Mat1<double>" );
    }

    ifs.getline( buf, buflen );
    sscanf( buf, "nx = %d", &nx );

    Mat1<double> r( nx );

    spdf_ifstream sifs(ifs);

    sifs.rd( &r[0], nrd, nx );

    if ( nrd != nx ) {
	throw( "Unable to recover Mat1<double>." );
    }

    v = r;

    p_require( ifs, "Mat1<double> : done.\n" );
}

//---------------------------------------------------------------------------//
// Write a Mat1<int> object.
//---------------------------------------------------------------------------//

void persist::prst_write( ofstream& ofs, const char *s, Mat1<int>& v )
{
    ofs << "Mat1<int>: " << s << " ==>" << endl;
    ofs << "nx = " << v.nx() << endl;

    spdf_ofstream sofs(ofs);

    sofs.wr( &v[0], v.nx() );

    ofs << "Mat1<int> : done.\n";
}

//---------------------------------------------------------------------------//
// Read a Mat1<int> object.
//---------------------------------------------------------------------------//

void persist::prst_read(  ifstream& ifs, const char *s, Mat1<int>& v )
{
    char name[ 100 ];
    int nx, nrd;
    
    p_require( ifs, "Mat1<int>: " );
    ifs.getline( buf, buflen );
    sscanf( buf, "%s ==>", name );
    if (strcmp(s,name)) {
	throw( "persist: unable to read Mat1<int>" );
    }

    ifs.getline( buf, buflen );
    sscanf( buf, "nx = %d", &nx );

    Mat1<int> r( nx );

    spdf_ifstream sifs(ifs);

    sifs.rd( &r[0], nrd, nx );

    if ( nrd != nx ) {
	throw( "Unable to recover Mat1<int>." );
    }

    v = r;

    p_require( ifs, "Mat1<int> : done.\n" );
}

//---------------------------------------------------------------------------//
//                              end of persist.cc
//---------------------------------------------------------------------------//
