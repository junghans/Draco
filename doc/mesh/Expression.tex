%%---------------------------------------------------------------------------%%
%% Expression.tex
%% Shawn Pautz
%% $Id$
%%---------------------------------------------------------------------------%%
\documentclass[11pt]{rnote}
\usepackage[centertags]{amsmath}
\usepackage{amssymb,amsthm,graphicx}
\usepackage[mathcal]{euscript}
\usepackage{tabularx}
\usepackage{cite}
\usepackage{c++}
\usepackage{tmadd,tmath}
\usepackage{../tex/stl}

%%---------------------------------------------------------------------------%%
%% DEFINE SPECIFIC ENVIRONMENTS HERE
%%---------------------------------------------------------------------------%%
%\newcommand{\elfit}{\ensuremath{\operatorname{Im}(-1/\epsilon(\vq,\omega)}}
%\msection{}-->section commands
%\tradem{}  -->add TM subscript to entry
%\ucatm{}   -->add trademark footnote about entry

%%---------------------------------------------------------------------------%%
%% BEGIN DOCUMENT
%%---------------------------------------------------------------------------%%
\begin{document}

%%---------------------------------------------------------------------------%%
%% OPTIONS FOR NOTE
%%---------------------------------------------------------------------------%%

\toms{Distribution}
%\toms{Joe Sixpak/XTM, MS B226}
\refno{XTM-RN(U)99-021}
\subject{Specification of the \concept{Expression Enabled Container}
  Concept}

%-------NO CHANGES
\divisionname{Applied Theoretical \& Computational Physics Div.}
\groupname{X-TM:Transport Methods Group}
\fromms{Shawn Pautz/XTM D409}
\phone{(505)667--9138}
\originator{sdp}
\typist{sdp}
\date{\today}
%-------NO CHANGES

%-------OPTIONS
%\reference{NPB Star Reimbursable Project}
%\thru{P. D. Soran, XTM, MS B226}
%\enc{list}      
%\attachments{list}
%\cy{list}
%\encas
%\attachmentas
%\attachmentsas 
%-------OPTIONS

%%---------------------------------------------------------------------------%%
%% DISTRIBUTION LIST
%%---------------------------------------------------------------------------%%

\distribution {
XTM MS D409:\\ 
J.E. Morel, XTM MS D409\\ 
G.L. Olson, XTM MS D409\\ 
J.M. McGhee, XTM MS D409\\ 
H.G. Hughes, XTM MS D409\\ 
T. Adams, XTM MS D409\\ 
M. Alme, XTM MS D409\\ 
T.M. Evans, XTM MS D409\\ 
M.G. Gray, XTM MS D409\\ 
M.L. Hall, XTM MS D409\\ 
S.D. Pautz, XTM MS D409\\ 
R.M. Roberts, XTM MS D409\\ 
S.A. Turner, XTM MS D409\\ 
T.J. Urbatsch, XTM MS D409\\ 
T.A. Wareing, XTM MS D409\\ 
J.S. Warsa, XTM MS D409\\ 
XDO MS B218:\\ 
}

%%---------------------------------------------------------------------------%%
%% BEGIN NOTE
%%---------------------------------------------------------------------------%%

\opening

\section{Introduction}

We describe the \concept{Expression Enabled Container} concept and 
a few important refinements of it. The ``expression enabled''
attribute allows one to apply combinations of mathematical operations
to corresponding elements of \C++ container classes by means of
algebraic expressions involving the containers themselves. This allows 
the user of such containers to avoid implementation details such as
loops and iterators and to use instead a more intuitive notation. The
use of such container classes should lead to more reliable code, since 
the user may implement desired operations in fewer lines that more
closely resemble the written mathematical notation. This set of
concepts is an important element in the design of the Draco component
library.

\section{Example}

Suppose that we have objects \comp{a}, \comp{b}, \comp{c}, and
\comp{d} of the same size and of the same array-like class
\comp{UserVec} and that we wish to implement some mathematical
operation involving them. One typical operation may be implemented by
the following standard \C++ coding technique:

\comp{for (int i = 0; i < a.size(); ++i)}
\break
\hspace*{0.25in}\comp{a[i] = b[i] + c[i]*sin(d[i]);}

The above operation could also be implemented by means of iterators if 
\comp{operator[]} were not defined. The problem with either of these
approaches is that the desired mathematical expression is obscured by
implementation details and every expression in the code requires these 
details to be rewritten, which increases the probability of
introducing bugs. If class \comp{UserVec} is an \concept{Expression
  Enabled Container}, however, the above code could be written as

\comp{a = b + c*sin(d);}

which more closely resembles familiar mathematical notation and
involves fewer lines of code.

\section{Implementation}

Any implementation that meets the requirements found in
Section~\ref{sec:concepts} is valid. One simple implementation is to
overload the basic functions and operations such as \comp{sin()} and
\comp{operator+} for the class under consideration; this generally
produces temporary objects at each step. A different implementation
approach is the expression template technique\cite{fu97}\cite{ve95};
this increases computational efficiency by eliminating the
construction of temporary objects. As noted above, though, no
particular implementation approach is required by the concept
definition.

\section{Concepts}
\label{sec:concepts}

The \concept{Expression Enabled Container} and related concepts
are defined below. The terminology and format are identical to that in
Ref. \cite{au99}.

\subsection{Expression Enabled Container}

An \concept{Expression Enabled Container} is a \concept{Container} for 
which all of the usual expression template expressions have been
defined. These expressions are not necessarily implemented with
expression templates.

\subsubsection{Refinement of}
\concept{Container} (\cite{au99}, page 125).

\subsubsection{Associated Types}

The same as for \concept{Container}, except that the requirements for
\comp{X::value\cu type} are strengthened. Each of the valid
expressions listed below must have overloaded versions defined for
\comp{X::value\cu type}.

\subsubsection{Notation}
\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.4\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
  \comp{X} & A type that is a model of \concept{Expression Enabled
    Container}. \\
  \comp{T} & \comp{X}'s value type. \\
  \comp{a} & Object of type \comp{X}. \\
  \comp{b,c} & Object of type \comp{X} or type \comp{T} or an
  expression. \\
\end{tabularx}

\subsubsection{Definitions}

\begin{deflist}
  \defitem{An {\it expression} is any combination of the
    non-assignment operations listed below operating on objects of
    type \comp{X} or \comp{T}. The return type of an expression is not 
    specified, but the expression must behave semantically as if the
    return type were \comp{X\&}.}
\end{deflist}

\subsubsection{Valid Expressions}

In addition to the expressions defined in \concept{Container}, the
following expressions must be valid.

\begin{exprlist}
  \expritem{Assignment}{a = b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{a} is mutable. \\
     Return type: & \comp{X\&}. \\
     Precondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     Postcondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. If \comp{b} is an object of type
     \comp{T}, then each element of \comp{a} is equal to \comp{b}.
     Otherwise \comp{a} contains a copy of each of \comp{b}'s
     elements. \\
     \end{tabularx}}
  \expritem{Assignment with addition}{a += b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{a} is mutable. \\
     Return type: & \comp{X\&}. \\
     Precondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator+=} being applied to
     each element of \comp{a} with \comp{b}, if \comp{b} is an object
     of type \comp{T}. Otherwise equivalent to \comp{T::operator+=}
     being applied to corresponding elements of \comp{a} and
     \comp{b}. \\
     Postcondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     \end{tabularx}}
  \expritem{Assignment with subtraction}{a -= b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{a} is mutable. \\
     Return type: & \comp{X\&}. \\
     Precondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator-=} being applied to
     each element of \comp{a} with \comp{b}, if \comp{b} is an object
     of type \comp{T}. Otherwise equivalent to \comp{T::operator-=}
     being applied to corresponding elements of \comp{a} and
     \comp{b}. \\
     Postcondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     \end{tabularx}}
  \expritem{Assignment with multiplication}{a *= b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{a} is mutable. \\
     Return type: & \comp{X\&}. \\
     Precondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator*=} being applied to
     each element of \comp{a} with \comp{b}, if \comp{b} is an object
     of type \comp{T}. Otherwise equivalent to \comp{T::operator*=}
     being applied to corresponding elements of \comp{a} and
     \comp{b}. \\
     Postcondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     \end{tabularx}}
\newpage
  \expritem{Assignment with division}{a /= b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Type requirements: & \comp{a} is mutable. \\
     Return type: & \comp{X\&}. \\
     Precondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator/=} being applied to
     each element of \comp{a} with \comp{b}, if \comp{b} is an object
     of type \comp{T}. Otherwise equivalent to \comp{T::operator/=}
     being applied to corresponding elements of \comp{a} and
     \comp{b}. \\
     Postcondition: & \comp{a.size() == b.size()}, unless \comp{b} is
     an object of type \comp{T}. \\
     \end{tabularx}}
  \expritem{Unary plus}{+b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{T::operator+} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Unary minus}{-b}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{T::operator-} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Addition}{b + c}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator+} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
\newpage
  \expritem{Subtraction}{b - c}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator-} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
  \expritem{Multiplication}{b * c}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator*} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
  \expritem{Division}{b / c}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{T::operator/} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
\newpage
  \expritem{Arc cosine}{acos(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{acos()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Arc sine}{asin(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{asin()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Arc tangent}{atan(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{atan()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Arc tangent 2}{atan2(b,c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{atan2()} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
\newpage
  \expritem{Cosine}{cos(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{cos()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Sine}{sin(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{sin()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Tangent}{tan(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{tan()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Hyperbolic cosine}{cosh(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{cosh()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
\newpage
  \expritem{Hyperbolic sine}{sinh(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{sinh()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Hyperbolic tangent}{tanh(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{tanh()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Exponential}{exp(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{exp()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Logarithm}{log(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{log()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
\newpage
  \expritem{Base-10 logarithm}{log10(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{log10()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Power}{pow(b,c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{pow()} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
  \expritem{Square root}{sqrt(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{sqrt()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Ceiling}{ceil(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{ceil()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
\newpage
  \expritem{Absolute value}{abs(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{abs()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Absolute value}{labs(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{labs()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Absolute value}{fabs(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{fabs()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
  \expritem{Floor}{floor(b)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if \comp{b} is not an object of type
     \comp{T}. Semantically, though, it should behave as if it were
     \comp{X\&}. \\
     Precondition: & Unless \comp{b} is an object of type \comp{T},
     this expression must be used in a statement that contains one of
     the assignment operators. \\
     Postcondition: & Unless \comp{b} is an object of type \comp{T},
     the resulting expression should behave semantically as a
     \comp{X\&} in which each element has been assigned the result of
     \comp{floor()} applied to corresponding elements of
     \comp{b}. \\
     \end{tabularx}}
\newpage
  \expritem{Modulus}{fmod(b,c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{fmod()} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
  \expritem{Minimum}{min(b,c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{min()} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
  \expritem{Maximum}{max(b,c)}
    {\begin{tabularx}{\linewidth}{>{\setlength{\hsize}{.5\hsize}}X
    >{\setlength{\hsize}{1.6\hsize}}X}
     Return type: & Undefined if either \comp{b} or \comp{c} is not an
     object of type \comp{T}. Semantically, though, it should behave
     as if it were \comp{X\&}. \\
     Precondition: & Unless \comp{b} and \comp{c} are both objects of
     type \comp{T}, this expression must be used in a statement that
     contains one of the assignment operators. \\
                   & \comp{b.size() == c.size()}, unless either
     \comp{b} or \comp{c} is an object of type \comp{T}. \\
     Semantics: & Equivalent to \comp{max()} being applied to
     each element of \comp{b} (or \comp{b} itself if \comp{b} is an
     object of type \comp{T}) with corresponding elements of \comp{c}
     (or \comp{c} itself if \comp{c} is an object of type
     \comp{T}). \\
     \end{tabularx}}
\end{exprlist}

\subsubsection{Complexity Guarantees}

All of the operations defined above are linear in the container's
size.

\subsubsection{Models}

All of the \comp{Mesh\cu XYZ} fields (in the Draco package) are models
of \concept{Expression Enabled Container}.

\subsection{Expression Enabled Forward Container}

An \concept{Expression Enabled Forward Container} is a
\concept{Forward Container} for which all of the usual expression
template expressions have been defined. These expressions are not
necessarily implemented with expression templates.

\subsubsection{Refinement of}
\concept{Forward Container} (\cite{au99}, page 131), \concept{Expression
  Enabled Container}.

\subsubsection{Models}

All of the \comp{Mesh\cu XYZ} fields (in the Draco package) are models
of \concept{Expression Enabled Forward Container}.

\subsection{Expression Enabled Random Access Container}

An \concept{Expression Enabled Random Access Container} is a
\concept{Random Access Container} for which all of the usual
expression template expressions have been defined. These expressions
are not necessarily implemented with expression templates.

\subsubsection{Refinement of}
\concept{Random Access Container} (\cite{au99}, page 135),
\concept{Expression Enabled Forward Container}.

\subsubsection{Models}

The \comp{Mesh\cu XYZ::tiny\cu vec<>} class (in the Draco package) is
a model of \concept{Expression Enabled Random Access Container}.

\bibliographystyle{../tex/rnote}
\bibliography{../bib/draco}

\closing
\end{document}

%%---------------------------------------------------------------------------%%
%% end of Expression.tex
%%---------------------------------------------------------------------------%%
