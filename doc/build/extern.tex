%%---------------------------------------------------------------------------%%
%% extern.tex
%%
%% how to make an external code package that uses draco fit in with
%% the draco build system
%%---------------------------------------------------------------------------%%

\chapter{Using the Draco Build Model in External Codes}
\label{chap:extern}

This chapter illustrates how to use the \draco\ and the \draco\ build
model in external code systems.  One of the advantages of \draco\ is
that it is independent from its clients.  Thus, one may use \draco\ 
without having any direct connections to its build system.  All that
is required is linking to the \draco\ libraries that one wishes to
use.  Details on how to use \draco\ as a client are given in
\S~\ref{sec:using}.

Code systems that use \draco\ heavily may find benefits in emulating
the \draco\ build model.  This prevents these systems from having to
define all of \draco's dependencies.  By using the \draco\ build
system they get the correct compile and link-line options
automatically.  We discuss how to use the \draco\ build system in
external codes in \S~\ref{sec:emulating}.

%%---------------------------------------------------------------------------%%

\section{Using Draco in External Codes}
\label{sec:using}

As mentioned in the previous section, \draco\ and external clients are
separate entities.  Thus, any build system that the external client
desires is acceptable.  This can range from a simple
``compile-script'' to a detailed \autoconf-\gmake\ or \cmake-based build system.
Describing all possible build systems that use \draco\ is beyond the
scope of this, or any, text.  However, we will point out some useful
items that should be considered when using \draco\ as an external
client.

First, clients of \draco\ should follow the \draco\ practice of
setting include paths to the \draco\ include directory specified by
\comp{CMAKE\_INSTALL\_PREFIX}.  Thus, headers should be included in source code
using
\begin{verbatim}
     #include "pkg/header.hh"
\end{verbatim}
For example, if a client wishes to use the \dsxx\ smart pointer class
then the client source code should contain the following:
\begin{verbatim}
     #include "ds++/SP.hh"
\end{verbatim}
The \draco\ headers are included on the compile and link-lines with the following statement
\begin{verbatim}
     -I /usr/local/draco/include
\end{verbatim}
where \comp{/usr/local/draco} is the \draco\ installation location.
By following this convention the client will avoid name clashes among
\draco\ packages.

\draco\ clients must remember to include all dependencies for a
particular \draco\ package.  These dependencies are both implicit and
explicit for \draco\ packages and vendors.  Tables~\ref{tab:depends}
and \ref{tab:vendor} can be used to determine the full list of
dependencies for a particular \draco\ package.  Additionally, clients
must remember to include the same vendor installations as the ones
supplied to \draco.  For example, if \draco\ used an \sys{OpenMPI}
version of \mpi\ then the client should use the same vendor and
version when linking.

As stated in \S~\ref{sec:overview_of_draco}, \draco\ uses the generic
programming archetype.  Thus, many classes and functions in \draco\ 
are templates and are not compiled into libraries.  \draco\ does not
support implicit instantiation~\cite{ansi:cpp} of template classes and
functions.\index{template!instantiation}  Thus, the user must provide explicit instantiation source
code for \draco\ template components.  \draco\ template code is stored
in \comp{.t.hh} and \comp{i.hh} files.  These files are installed in the
\comp{include/} directory along with the rest of the \draco\ package
headers. Specific information on the generic programming approach used in 
\draco\ is given in ref.~\cite{ro98}.

%%---------------------------------------------------------------------------%%

\section{Emulating the Draco Build System}
\label{sec:emulating}

The \draco\ build system can be emulated at varying levels ranging
from full to minor.  We will describe a method for using the \draco\ 
build system directly.  If this method is used the \draco\ build
system requires little or no modification in the external system.
External code systems that utilize the \draco\ build system in this
manner are \pkg{Capsaicin}, \pkg{ClubIMC}, \milagro, and \pkg{Wedgehog}.

The most direct method of incorporating the \draco\ build system into
an external product is to mimic the structure of the \draco\ source
tree.  This process has three steps:
\begin{enumerate}
\item Setup the external code source tree in the same manner as
  \draco; setup a top-level directory, a \comp{src/} directory, a
  \comp{doc/} directory, and a \comp{pkg\_config} directory.  Components of 
  the code should be placed in \comp{src/\vble{pkg}/} directories.
\item build system macros that are specific to the external code or replace \draco\ specific versions should be placed in the \comp{pkg\_config} directory.
\item When configuring, set the \comp{CMAKE\_INSTALL\_PREFIX} tag to the same location as the installed \draco\ components.
\end{enumerate}
If these steps are followed, then the external code system should
properly attach \draco\ libraries and find \draco\ headers.  However,
the external code developer should be aware that external code
components will be installed in the same location as \draco\ 
components.

The \draco\ design allows both the \draco\ build system and its installed components to be used in an external code system.  In this model, \draco\ must be installed in an accessible location.  The external code system can load the \draco\ build system by adding the \comp{\$draco\_install/config} directory to the \comp{CMAKE\_MODULE\_PATH} allowing the external code system to use any or all of the \draco\ build system.  

%Including the \draco\ components in external components is easily
%accomplished using \cvs.  Through \cvs\ module control we have
%included the \comp{draco/config} directory into the \milagro\ and
%\solon\ code systems.  Thus, these systems will automatically get
%updates of the \draco\ build system components.  This option is only
%available to \draco\ developers who have access to the \draco\ \cvs\ 
%repository.

Each package subdirectory in the external code system must have a
\comp{CMakeLists.txt} file as described in \S~\ref{sec:adding_overview}.
The contents of these files are described in
\S~\ref{sec:package_files}.  These files will be very similar to the
\comp{CMakeLists.txt} files found in \draco.  The fundamental
difference is that the external code will add its own package
dependencies to the existing \draco\ dependencies.
Chapters~\ref{chap:adding} and \ref{chap:extend} go into greater
detail on package design in the \draco\ build system.

Additionally, the external code may require vendors that are not
supported by \draco.  Thus, vendor discover and setup in addition to those shown in
Table~\ref{tab:vendortags} may need to be defined.  Defining vendors
using \draco-like methodology is described in
Chap.~\ref{chap:extend}.  

On a final note, any deviations from the \draco\ build model in an
external code system are perfectly acceptable.  The external code
client and \draco\ are independent entities.  In many cases, exactly
emulating \draco\ is the most straightforward way of incorporating
\draco\ into an external code package.  
%An additional benefit of
%emulating the \draco\ build system is that one gains a GNU Standard
%system.

%%---------------------------------------------------------------------------%%

\section{Summary}

We have given directions on how to use \draco\ in an external code
system.  In \S~\ref{sec:emulating} we have shown how to directly use
\draco\ in a code system that makes heavy use of the \draco\ component 
library.  In \S~\ref{sec:using} we have given some pointers to codes
that are \draco\ clients but simply want to link to \draco\
components without using the \draco\ build system.