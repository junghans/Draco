%%---------------------------------------------------------------------------%%
%% matFactory.tex
%% Randy M. Roberts
%% $Id$
%%---------------------------------------------------------------------------%%
\documentclass[11pt]{nmemo}
\usepackage[centertags]{amsmath}
\usepackage{amssymb,amsthm,graphicx}
\usepackage[mathcal]{euscript}
\usepackage{tmadd,tmath}
\usepackage{cite}
\usepackage{c++}
\usepackage{fancycodes}
\usepackage[dvips]{color}

%%---------------------------------------------------------------------------%%
%% DEFINE SPECIFIC ENVIRONMENTS HERE
%%---------------------------------------------------------------------------%%
%\newcommand{\elfit}{\ensuremath{\operatorname{Im}(-1/\epsilon(\vq,\omega)}}
%\msection{}-->section commands
%\tradem{}  -->add TM subscript to entry
%\ucatm{}   -->add trademark footnote about entry

\definecolor{codecolor}{rgb}{0,0,1}
\definecolor{comcolor}{rgb}{1,0,0}
\newcommand{\cxxcom}{\color{comcolor}}
\newcommand{\cxxcode}{\color{codecolor}}

\newcommand{\code}[1]{\textbf{\texttt{\textcolor{codecolor}{#1}}}}

\newcommand{\tmpl}[1]{$<$#1$>$}

\newcommand{\MFT}{\code{Matrix\-Factory\-Traits}\ }

%%---------------------------------------------------------------------------%%
%% BEGIN DOCUMENT
%%---------------------------------------------------------------------------%%
\begin{document}

%%---------------------------------------------------------------------------%%
%% OPTIONS FOR NOTE
%%---------------------------------------------------------------------------%%

\toms{Distribution}

\refno{XTM-99-??? (U)}
\subject{Matrix Factory Traits}

%-------NO CHANGES
\divisionname{Applied Theoretical \& Computational Physics Div.}
\groupname{X-TM:Transport Methods Group}
\fromms{Randy M. Roberts/XTM D409}
\phone{(505)665--4285}
\originator{rmr}
\typist{rmr}
\date{\today}
%-------NO CHANGES

%-------OPTIONS
%\reference{NPB Star Reimbursable Project}
%\thru{P. D. Soran, XTM, MS B226}
%\enc{list}      
%\attachments{list}
%\cy{list}
%\encas
%\attachmentas
%\attachmentsas 
%-------OPTIONS

%%---------------------------------------------------------------------------%%
%% DISTRIBUTION LIST
%%---------------------------------------------------------------------------%%

\distribution {}

%%---------------------------------------------------------------------------%%
%% BEGIN NOTE
%%---------------------------------------------------------------------------%%

\opening

\section{Introduction}

One design requirement for the diffusion solver used by the
Solon P1 3T package is the ability to 
incorporate disparate linear algebra packages.
A complication resulting from this requirement arises from each linear
algebra package having different matrix representations.
The diffusion solver
must have a mechanism to generate matrices of differing representations
using a common mechanism.
We propose using a \emph{traits} based
 \MFT
mechanism\cite{Austern99}\cite{Myers96}
as this common mechanism.%
\footnote{This leads to a pattern that I have named the
  \code{Factory Traits} pattern.
  It is basically a variation of \S Implementation \P 4
  of the \code{Factory Method}
  pattern\cite{Gamma95}.}

These differing matrix representations result from requirements for
the efficient storage and manipulation of matrix
of multiple linear system structures, and the solution algorithms.
For example, the linear system resulting
from a one-dimensional three-point standard
diffusion stencil may best be represented by a tri-diagonal matrix.
The solution of this system should
be specialized specifically for a tri-diagonal
system\cite{Press92}.

The diffusion solvers under Draco cannot know about every possible matrix
representation for every possible linear algebra package.
With a common mechanism to create a matrix of any desired representation,
the diffusion solver can be written independent of the linear algebra
package.
When a new linear algebra package is incorporated into Draco, it will be part
of the incorporation task to specialize a \MFT class
for each new matrix representation.
The details of this process will be discussed below.

\section{Overview}

Draco will support its own set of matrix representations, to be used during
the generation of linear systems, independent of those defined by the 
linear algebra packages.
These will probably not be the most efficient representations for matrix
computations, but will be efficient for generating linear systems of various
structures.
For example, we may have a dynamic compressed row storage representation that
is very efficient for the insertion of new elements into a linear
system with an unknown sparsity pattern.
Another Draco matrix may be most efficient for representing a three-dimensional,
nine-point structured diffusion system.

The \MFT mechanism would facilitate the creation
of a matrix of unforeseen representation, specified by the linear algebra
package, from one or more of the Draco matrix
representations.

\section{How the \MFT mechanism is used.}

The \MFT mechanism relies on \MFT classes, specialized for each
of the linear algebra package's matrix representations.
These class specializations
provide \code{create} static class methods, which take
a constant reference to a Draco specified matrix representation, and create
pointers to the linear algebra package's matrices.

The Draco diffusion solver would generate a Draco-defined matrix that most
efficiently represents the linear system that the diffusion solver generates.
The diffusion solver then fills the Draco-defined matrix, or perhaps has already
done so during the call to the matrix's constructor.

\begin{ttfamily}
\cxxcode
  MyDracoMatrix myDracoMatrix(...);
\end{ttfamily}

After the Draco-defined matrix is generated, it is passed to the
\code{create} utility of a \MFT class
that has been specialized for the desired linear algebra package matrix.

\begin{ttfamily}
\cxxcode
  NewMatrix *matrix = 
    MatrixFactoryTraits<NewMatrix>::create(myDracoMatrix);
\end{ttfamily}

The following main program demonstrates how the common
\MFT mechanism is used.
In this case the \code{DenseMatrixRep} is a Draco-defined matrix
representation, and the \code{JoubertMat} is a matrix defined by a
linear algebra package.

\subsection{main.cc}

\begin{ttfamily}
\begin{small}
\cxxcode
\input{main.cc.cfg}
\end{small}
\end{ttfamily}

\section{How the \MFT mechanism is implemented.}

The default \MFT class defines the \code{create} utility that is
templated to take any type object as its
argument and will purportedly return a pointer to the type specified
by the \MFT template argument.
I use \emph{purportedly} because the default \MFT class is designed
to fail at \emph{compile time}
if not specialized with the desired matrix representation.
It tries to invoke its \code{BogusMethod} utility, which has purposely
been left undefined.

This mechanism is used to provide an not so subtle reminder to the
linear algebra package integrator to specialize the \MFT class with
the desired matrix representations.

\subsection{MatrixFactoryTraits.hh}

\begin{ttfamily}
\begin{small}
\cxxcode
\input{MatrixFactoryTraits.hh.cfg}
\end{small}
\end{ttfamily}

\section{How the \MFT mechanism is specialized.}

The \MFT class is specialized on the type of matrix that is to be created.
The \code{create} class utilities are then specified with the desired input
arguments.

The \code{create} class utilities can be created specifically for each desired
input argument type, or one can use a templated \code{create} class utility
to accommodate a broad range of input arguments.
In the latter case there should be some compile-time or run-time means
to determine the appropriateness of the input argument.

The example specialization in \code{JoubertMatTraits.hh} uses a combination
of the two approaches.
It specifies an overloaded \code{create} static method that takes a
\code{CRSMatrixRep} as the
input argument type.
Additionally, the class specifies a templated version of \code{create}
that takes any other input argument type.
The templated version of \code{create} is an inlined static member function
that immediately converts its input argument to a \code{CRSMatrixRep}, and
then calls the overloaded version of \code{create}.
This provides
a compile-time means for limiting the appropriate input arguments, in
that compiling code that contains \code{create} invocations with
arguments that do not have conversions to \code{CRSMatrixRep} specified
will result in compile-time errors.
This particular example does not provide run-time checking of the input
arguments, since it is always possible to represent any matrix of any
structure using a compressed row storage matrix.

\subsection{JoubertMatTraits.hh}

\begin{ttfamily}
\begin{small}
\cxxcode
\input{JoubertMatTraits.hh.cfg}
\end{small}
\end{ttfamily}

\subsection{JoubertMatTraits.cc}

\begin{ttfamily}
\begin{small}
\cxxcode
\input{JoubertMatTraits.cc.cfg}
\end{small}
\end{ttfamily}

\section{Downsides of this Mechanism}

The one downside of this mechanism, as laid out, is that the traits class
results in a static method invocation, as opposed to a functor invocation.
This means that no state is associated with the \MFT class.

As yet this does not seem like a large downside, since some state is being
passed into the \code{create} utility via its input argument.

\bibliographystyle{apalike}

\bibliography{matFactory}

\closing
\end{document}

%%---------------------------------------------------------------------------%%
%% end of matFactory.tex
%%---------------------------------------------------------------------------%%
