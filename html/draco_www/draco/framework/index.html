<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>No Title</TITLE>
<META NAME="description" CONTENT="No Title">
<META NAME="keywords" CONTENT="framework">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="framework.css">
<LINK REL="next" HREF="node1.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html1"
 HREF="node1.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./next_motif.gif"></A> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./up_motif_gr.gif"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./previous_motif_gr.gif">   
<BR>
<B> Next:</B> <A NAME="tex2html2"
 HREF="node1.html">About this document ...</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<P>
<DIV ALIGN="CENTER">
Generic Programming and the Methods-Integration Split
<BR>
Mark G. Gray
<BR>
XTM Unstructured Mesh Team
<BR>
Monday 15 December 1997
</DIV>
<P>
<FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT>
<DIV ALIGN="CENTER">
The New X Order
</DIV>
With the separation of Methods and Integration responsibilities, our
division has taken a step into a New X Order.  In the New X Order how
do we develop Methods so that Integration in codes can take place?
How do we understand the responsibilities of the Methods and
Integration groups?  How can we help each other do a good job?

<P>
Traditionally, physics packages (which in the NXO are to be created by
Methods groups) were integrated into codes (which in the NXO is the
job of the Integration group) in one of the following ways:<FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
Traditional X Development
</DIV><UL>
<LI>The ``one-off'' approach: a package is written specifically to
support the data structures of a particular code.  This would be hard
on the Methods group, since they would spend a large amount of time
writing the same methods for different data structures (codes), and
then perhaps justifying why they aren't developing new methods.
<LI>The library approach: a package is written to support one
specific set of data structures.  This would be hard on the
Integration group, since they would spend a large amount of time
reshaping the code's data structures to conform with the set chosen by
the library writer, and then perhaps explaining why the result performs
poorly.
<LI>The ``no-off'' approach: the package is attempted in either of
the two above forms, but the job is so hard that it never gets done.
This would be hard on everybody!
</UL><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
The Question
</DIV><FONT COLOR="#ff0000">How can we operate in the New X Order while avoiding
the pitfalls of traditional development approaches?</FONT>

<P>
Let's look closely at a small illustrative example, keeping in mind
the M-I split in the NXO, and the failures of the past.  Consider a
statistical analysis package written in the library approach ...<FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
Standard Library Approach
</DIV><PRE>
class statistics
{
    double avg(const double *x, int n)
    {
        double sum = 0;
        for (int i = 0; i &lt; n; i++)
            sum += x[i];
        return (sum/n);
    }
    // plus many other statistics services
};
</PRE>
which can be used as follows:<PRE>
double d[3] = {3, 2, 1};           // d an array of 3 doubles
statistics s;                      // statistics methods on doubles
cout &lt;&lt; s.avg(d, 3);               // print out the double average
</PRE><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
What's wrong with the Standard Library Approach
</DIV>
There is an asymmetry here:<UL>
<LI>The library provides <FONT COLOR="#00ffff">procedures</FONT> written by its author
<LI>The library requires <FONT COLOR="#ff0000">data</FONT> provided by its user 
</UL>
Writing the library is easy on the Methods writer because he gets to
specify the procedures (which no one else could) <B>and</B> the data
structures.  Using the library is hard on the Integration group since
they <B>must</B> put their data into the form required by the
library.  Worse still, if the data changes too much, if, for example,
statistics on <TT>complex</TT> types are required, then the library must
change.  

<P>
<FONT COLOR="#ff0000">Can we do better?</FONT> <FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
Template Library Approach
</DIV><PRE>
template&lt; class T &gt;
class statistics
{
    T avg(const T *x, int n)
    {
        T sum = 0;
        for (int i = 0; i &lt; n; i++)
            sum += x[i];
        return (sum/n);
    }
    // plus many other statistics services
};
</PRE>
which can be used as follows:<PRE>
double d[3] = {3, 2, 1};           // d an array of 3 doubles
statistics&lt; double &gt; s;            // statistics methods on doubles
cout &lt;&lt; s.avg(d, 3);               // print out the double average
</PRE><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
What's better in the Template Library Approach.
</DIV>
The Template Library approach solves one of the problems with the
library approach because in addition to supporting <TT>double</TT>, this
<TT>statistics</TT> class can be used with <TT>complex</TT>, <TT>rational</TT>,
<TT>interval</TT>, or <B>any</B> type that is ``<TT>double</TT> like''.

<P>
This sounds too good to be true.  

<P>
<FONT COLOR="#ff0000">What's the catch?</FONT><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
The Catch in Template Library Approach
</DIV>
Class <TT>T</TT> <B>must</B> provide the following services:<PRE>
class T
{
    T(int i);                      // so T can be initialized with 0
    T &amp;operator+=(const T &amp;);      // so T can be added and assigned
    T &amp;operator/(int n);           // so T can be divided by n
};
</PRE>
For example, consider:<PRE>
class interval
{
    interval(int i) { l=u=i };
    interval &amp;operator+=(const T &amp;t) { l += t.l; u += u.l; return *this };
    interval &amp;operator/(int n) { l /= n; u /= n; if (n&lt;0) swap(u, l); 
                         return *this }; 
    // other methods
private:
    double l, u;                   // endpoints of interval
};

interval i[3] = {3, 2, 1};         // i an array of 3 intervals
statistics&lt; interval &gt; s;          // statistics methods on intervals
cout &lt;&lt; s.avg(i, 3);               // print out the interval average
</PRE> works as expected.  

<P>
<FONT COLOR="#ff0000">Can we do better?</FONT><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
The Generic Programming Approach
</DIV><PRE>
template&lt; class C &gt;
class statistics
{
    C::elT avg(const C &amp;x)
    {
        typename C::elT sum = 0;
        for (int i = 0; i &lt; x.size(); i++)
            sum += x[i];
        return (sum/x.size());
    }
    // plus many other statistics services
};
</PRE>
where the container class <TT>C</TT> must provide the
following services:<PRE>
template&lt; class T &gt;
class my_C
{
    typedef T elT;                 // export data type T
    T operator[](int i);           // array like indexing
    int size();                    // size
    // plus other container services
};
</PRE> and the class <TT>T</TT> must provide services as before.  <FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
The Generic Programming Approach
</DIV><TT>my_C</TT> can be used as follows: <PRE>
my_C&lt; double &gt; d(3, 3, 2, 1);      // d an array of 3 doubles
statistics&lt; my_C&lt; double &gt; &gt; s;    // statistics methods on doubles
cout &lt;&lt; s.avg(d);                  // print out the double average
</PRE>

<P>
In fact, the user can now use any container class with any data type, as
long as the container class is ``<TT>array</TT> like and the data type is
``<TT>double</TT> like''.  This gives the user independence from data
and layout.  Further, we have symmetry: <UL>
<LI>The Generic Program provides <FONT COLOR="#00ffff">services</FONT> written
by its author
<LI>The Generic Program requires <FONT COLOR="#00ffff">services</FONT> written
by its user 
</UL>
<FONT COLOR="#00ffff">Why is this better?</FONT><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
Why Specification by Services is a Good Thing.
</DIV>
The generic programming's specification by services is better than the
library's specification by procedures and data structures because it
conforms to some fundamental tenets of the Object-Oriented approach,
namely: <UL>
<LI>Service specifications are less volatile than data
specifications
<LI>Service specifications are more abstract-able than data
specifications
<LI>Services can be designed by contract
</UL><FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<FONT SIZE="-1"><FONT SIZE="-1"><FONT COLOR="#0000ff"><U>Generic Programming and the M-I split</U></FONT>
</FONT></FONT>
<DIV ALIGN="CENTER">
Conclusion
</DIV>
The generic programming approach gives the Methods group and the
Integration group equal responsibilities and benefits.  Both groups
work from a set of abstract service specifications in the form of
contracts.  Each is sure of exactly what needs to be done on his side,
and can verify the correctness of what was done on the other side.
Both benefit from having a more stable set of specifications since
they written in terms of specifications and not data.<FONT SIZE="-1"><FONT COLOR="#0000ff">
<BR>
LANL XTM Unstructured Mesh Team <BR>
<BR>
------------
<BR>
<BR></FONT>
</FONT>
<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS">&#160;</A>
<UL>
<LI><A NAME="tex2html3"
 HREF="node1.html">About this document ... </A>
</UL>
<!--End of Table of Child-Links-->
<HR>
<!--Navigation Panel-->
<A NAME="tex2html1"
 HREF="node1.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="./next_motif.gif"></A> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="./up_motif_gr.gif"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="./previous_motif_gr.gif">   
<BR>
<B> Next:</B> <A NAME="tex2html2"
 HREF="node1.html">About this document ...</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>John McGhee</I>
<BR><I>1998-05-13</I>
</ADDRESS>
</BODY>
</HTML>
