<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Evaluation</TITLE>
<META NAME="description" CONTENT="Evaluation">
<META NAME="keywords" CONTENT="cip">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="cip.css">
<LINK REL="next" HREF="node8.html">
<LINK REL="previous" HREF="node6.html">
<LINK REL="up" HREF="cip.html">
<LINK REL="next" HREF="node8.html">
</HEAD>
<BODY >

<A NAME="tex2html90"
 HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html88"
 HREF="cip.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html82"
 HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>   <BR>
<B> Next:</B> <A NAME="tex2html91"
 HREF="node8.html">Conclusion</A>
<B>Up:</B> <A NAME="tex2html89"
 HREF="cip.html">Container-Free Numerical Algorithms in</A>
<B> Previous:</B> <A NAME="tex2html83"
 HREF="node6.html">Adaptors</A>
<BR> <P>

<!--End of Navigation Panel-->

<H1><A NAME="SECTION00070000000000000000">
Evaluation</A>
</H1>

<P>
Let us now survey the landscape.  We have considered the problems
endemic to fixed argument type interfaces.  We have considered
generalizations that template algorithms on the input data types, but
leave those types burdened with various explicit and implicit
constraints.  We have looked at generalizations that use traits to
provide a mapping between services needed by an algorithm and services 
provided by a container.  And we have seen how to write adaptors that
present one interface to an algorithm, implemented in terms of
different services provided by a container.  By this point we have an
extraordinary amount of flexibility available to us.  What is the
right mix?

<P>
Fundamentally, the issue is who has to do the work.  In the old days
of fixed argument type subroutine interfaces, the burden of reuse was
placed squarely on the shoulders of the application programmer.  If
the application's data was not in the format proscribed by the library
developer, then the application programmer had to do whatever it
took--anything from copying data to a new container, to rewriting the
source code expression of the algorithm.  Now the library developer
can bear a share of the burden through template parameterization and
reliance on traits classes.  How far should the pendulum swing?

<P>
Asked another way, what are reasonable assumptions that a library
developer should be able to make of an application's containers, and
what things should be delegated to a traits class?  For example, note
that <TT>ltsolve3</TT> could have eliminated even the constraint that the
input types have an <TT>operator()</TT>.  This could certainly have been
handled through the introduction of another trait, say <TT>cip_traits&lt;T&gt;::get_data()</TT>, thus abstracting out even the requirement
that the container be addressable through <TT>operator()</TT>.  This
would make the algorithm even more general than it already is, at the
cost of making the library developer jump through even more hoops to
accommodate the application's container types.

<P>
In my view, there is probably no ``right'' way to make judgment calls 
of this sort and it is not my purpose in this article to advocate
specific ``standard'' constraints.  Rather I think that the scientific 
community will have to acquire some experience with these issues over
the coming months and years as scientific subroutine libraries become
available utilizing these techniques.  The issue is not so much what
constraints a library developer places on client container types, as
it is how well these constraints are documented.  For example, a
linear algebra solver library might constrain user defined matrix types
to support an <TT>operator()(int,int)</TT>.  But a specific application
developer might build a sparse matrix which did not support indexing in
this manner since most locations are expected to be empty.  Even in
such a case, the application is not prevented from calling the
library's algorithms, since it is always possible to build an adaptor
which maps the <TT>operator()(int,int)</TT> calls which will be made by
the library algorithm, to whatever services the sparse matrix actually 
provides.  What is important in this case is that the constraints be
well documented, so that the application developer will know what is
required by the library, and be able to provide either traits
specializations or adaptors that meet these requirements.  And adjunct 
observation is that library developers should use design by contract
to enforce any implicit constraints which are placed on the
application containers, as shown in <TT>ltsolve3</TT>.

<P>
<HR>
<A NAME="tex2html90"
 HREF="node8.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html88"
 HREF="cip.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html82"
 HREF="node6.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A>   <BR>
<B> Next:</B> <A NAME="tex2html91"
 HREF="node8.html">Conclusion</A>
<B>Up:</B> <A NAME="tex2html89"
 HREF="cip.html">Container-Free Numerical Algorithms in</A>
<B> Previous:</B> <A NAME="tex2html83"
 HREF="node6.html">Adaptors</A>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Mark Gray <BR>
1998-05-20</I>
</ADDRESS>
</BODY>
</HTML>
