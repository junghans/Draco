#! /bin/sh 
#$Id$
#  This sample script is a wrapper for running MPI jobs under lsbatch.
#  Submit job by saying "bsub [otheroptions] -n k mpijob command line",
#  where k is the number of hosts to use; mpijob is the name of this script.
#
#  Note the variable LSB_HOSTS is assigned by lsbatch system when this script
#  is started by lsbatch.

$LSB_TRAPSIGS 

dryrun=0
verbose=0
device_tcp=1
device_mpl=0
lsf_requeue=0
#
# runit.tmpl module will be included upon installation
#
# Do not remove the following two lines!
#RUNIT_MODULE_BEGIN#
#
# runit_unix()
#
# This func takes the global var $COMMANDLINE,
# executes the command and sets the $exstat with the exit
# status of the command
#
runit_unix() {
    eval $COMMANDLINE
    exstat=$?
}

#
# runit_mpl()
#
# This func takes the global var $COMMANDLINE
# and then sets the var $exstat to 
#    (1) first value of $REQUEUE_EXIT_VALUES   if (poe couln't allocate nodes)
#    (2) exit status of the command            otherwise
#
runit_mpl() {
    POE_ERRFILE="/tmp/poejob.$$"
    tmpfiles="$tmpfiles $POE_ERRFILE"

    eval poe $COMMANDLINE 2>$POE_ERRFILE
    exstat=$?

    if [ -n "`grep 't allocate nodes for parallel' $POE_ERRFILE`" ] ; then
        if [ x"$LSB_EXIT_REQUEUE" = "x" ] ; then
	    true
        else 
	    lsf_requeue=1
	    # take the first value of the REQUEUE_EXIT_VALUES
	    if [ x"REQUEUE_EXIT_VALUES" = x ] ; then
	        echo "poejob: fatal error REQUEUE_EXIT_VALUES not set!" 1>&2
	    else
		exstat=`echo $REQUEUE_EXIT_VALUES|awk {print $1}`
            fi
        fi
    fi
}
#RUNIT_MODULE_END#

count_items () {
    num_items=0
    for item in $* ; do
	let "num_items=num_items+1"
    done
    echo $num_items
}

get_HOST_S () {
    nhost=$1
    hostlist="$LSB_HOSTS"
    while [ -n "$hostlist" ] ; do
	let "maxp=maxp-1"
	last=""
	remhosts=""
        for host in $hostlist ; do
	    if [ "X$last" = "X$host" ] ; then
		remhosts="$remhosts $host"
	    else
		let "nhost=nhost-1"
		last="$host"
		HOST_S="$HOST_S $host"
	    fi
	    [ $nhost -lt 1 ] && break 2
	done
	hostlist="$remhosts"
    done
}

get_MAXPROC () {
    MAXPROC=`count_items $LSB_HOSTS`
}
   

#
# Temporary files to be removed before exit
#
tmpfiles=


#
# Parse Arguments
#
while [ 1 -le $# ] ; do
    arg=$1
    shift
    case $arg in
	-tcp)
	  ;;
	-mpl)
	  device_mpl=1
	  device_tcp=0
	  ;;
        -dryrun)
	  dryrun=1
	  ;;
        -v)
          verbose=1
          ;;
	mpirun)
	  break
	  ;;
         *)
	  echo "Usage: mpijob [ -v ] mpirun program [program args]"
	  exit 1
	  ;;
    esac
done

#
# Parse mpirun arguments
#
HOST_LIST="$LSB_HOSTS"
get_MAXPROC
COMMANDLINE=""
progname=""
while [ 1 -le $# ] ; do
    arg=$1
    shift
    case $arg in
	-arch)
	  COMMANDLINE="$COMMANDLINE -arch \"$1\""
	  shift
	  ;;
	-machine)
	  COMMANDLINE="$COMMANDLINE -machine \"$1\""
	  shift
	  ;;
	-machinefile)
	  echo "$0: mpirun parameter [-machinefile] cannot be used with mpijob"
	  exit 1
	  ;;
	-np)
	  NP=$1
	  # Validate -np parameter
	  if [ $NP -gt $MAXPROC ] ; then
		echo "$0: mpirun parameter [-np $NP] requesting too many processors"
		exit 1
	  elif [ $NP -le 0 ] ;then
		echo "$0: mpirun parameter [-np $NP] must be greater than zero."
		exit 1
	  fi
	  get_HOST_S $NP
	  HOST_LIST="$HOST_S"
	  shift
	  ;;
	-stdin)
	  COMMANDLINE="$COMMANDLINE -stdin \"$1\""
	  shift
	  ;;
	-*)
	  COMMANDLINE="$COMMANDLINE \"$arg\""
	  ;;
	*)
	  progname=$arg
	  break
	  ;;
    esac
done
CMD=${progname##*/}

#
# if no programs specified 
#
if [ "X$progname" = "X" ] ; then
    echo "Usage: mpijob [ -v ] mpirun [mpirun args] program [program args]"
    exit 1
fi

COMMANDLINE="$COMMANDLINE $progname"
while [ $# -gt 0 ] ; do
    COMMANDLINE="$COMMANDLINE \"$1\""
    shift
done

#
# Build absolute path for the program instance
#
PWD_TRIAL=`pwd | sed -e 's%/tmp_mnt/%/%g'`
if [ ! -d $PWD_TRIAL ] ; then 
    echo "Warning: your default path uses the automounter; this may"
    echo "cause some problems if you use other NFS-connected systems."
    PWD_TRIAL=`pwd`
fi

#
# The test for PWD_TRIAL usable is within the p4/execer/tcp test (since that
# is where it matters)
#
tail=`echo $progname | sed 's/\/.*//'` 
if  [ "$tail" = "" ] ; then
    #echo Absolute path, don't need to change anything
    true
else
    #echo Relative path
    progname="$PWD_TRIAL/$progname"
fi

if [ $verbose = 1 ] ; then
    echo Absolute path $progname
fi

#
# Generate hostfile
#

#
# sanity check
#
if [ x"$LSB_HOSTS" = "x" ] ; then
    echo "mpijob is only used to run batch jobs"
    echo "please use bsub to submit a job"
    exit 1
fi
 
HOSTFILE=$HOME/.lsbatch/host$$.`hostname`
rm -f $HOSTFILE
touch $HOSTFILE
tmpfiles="$tmpfiles $HOSTFILE"

firsthost=1
for host in $HOST_LIST 
do

#
# Create procgroup file
#
# for the MPICH implementation
#
    if [ $device_tcp = 1 ] ; then
      if [ $firsthost = 1 ] ; then
        echo $host 0 $progname>> $HOSTFILE
        firsthost=0
      else
	echo $host 1 $progname>> $HOSTFILE
      fi
    else
      echo $host >> $HOSTFILE
    fi
done

if [ $device_tcp = 1 ] ; then
    COMMANDLINE="mpirun -p4pg $HOSTFILE $COMMANDLINE"
else
    COMMANDLINE="$COMMANDLINE -machinefile $HOSTFILE"
fi    

#
# run MPI job and save exit status.
#

if [ $verbose = 1 ] ; then
    echo PROCGROUP
    cat $HOSTFILE
    echo "COMMAND"
    echo $COMMANDLINE
fi

if [ $dryrun != 1 ] ; then
     if [ $device_tcp = 1 ] ; then
         runit_unix
     else
         runit_mpl
     fi
else
    echo $COMMANDLINE
fi

# Kill runaway processes

# This check is-overzealous and is killing jobs during the regression test.
if [ $lsf_requeue = 1 ] ; then
    true
else
    if [ $device_tcp = 1 ] ; then
	if [ $dryrun != 1 ] ; then
#	    lsgrun -p -m "$LSB_HOSTS" zapit -9 mpirun mpijob >/dev/null 2>&1
#	    lsgrun -p -m "$LSB_HOSTS" zapit -9 $CMD mpijob >/dev/null 2>&1
	    true
	fi
    fi
fi

if [ x"$tmpfiles" != "x" ] ; then
    rm -f $tmpfiles
fi


echo "Exit value: $exstat"
exit $exstat
